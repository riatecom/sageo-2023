---
title: "Articulation de différents langages (R, JavaScript et Python) pour la géovisualisation avec Quarto"
subtitle: "Atelier Sageo, Québec, Juin 2023"
author: 
  - name: "Timothée Giraud, Nicolas Lambert, Matthieu Viry, Ronan Ysebaert"
    affiliations:
      - id: 1
        name: RIATE (CNRS, Université Paris Cité)
        url: https://riate.cnrs.fr
format:
  html:
    theme: sandstone
    fontsize: 0.9em
    code-tools: true
    toc: true
    toc-depth: 2
    linkcolor: "#8631ad"
execute: 
  cache: false
editor_options: 
  chunk_output_type: console
bibliography: references.bib
csl: "universite-de-montreal-apa.csl"
lang: fr
resources: "quebec.zip"

---

![](fig/SAGEO.png)

## Présentation

Dans un contexte d'essor de carnets interactifs (*notebooks*), l'objet de cet atelier consiste à montrer les possibilités offertes par Quarto, un système de publication scientifique et technique open source basé sur Pandoc, qui permet d'articuler différents langages pour réaliser des géovisualisations reproductibles dans un seul et même document. Cet atelier proposera aux participants une prise en main des principales fonctionnalités offertes par Quarto, puis une mise en œuvre de chaînes de traitements de l'information géographique reproductibles avec R, Python et Observable JavaScript dans cet environnement.

### Déroulé de la demi-journée

-   Installation des logiciels nécessaires à la mise en place de l'environnement de développement (Quarto, R, Python, RStudio, etc.).
-   Présentation et prise en main des principales fonctionnalités des notebooks Quarto. Présentation des écosystèmes spatiaux de R et Python, et, d'un jeu de données commun sur lequel s'appuiera l'ensemble de l'atelier.
-   Traitement des données vectorielles : Mise en pratique d'une chaîne de traitements reproductible avec R, notamment grâce aux packages `sf` et `mapsf.`
-   Traitement des données raster : Mise en pratique d'une chaîne de traitements reproductible avec Python (bibliothèques `geopandas`, `rasterio`, `xarray`, `matplotlib`, etc.).
-   Création de visualisations cartographiques interactives avec ojs (bibliothèques `bertin`, `Plot`, `Gridviz`, `Deck.gl`).
-   Export du document quarto produit pendant l'atelier (templates de différentes revues scientifiques, slides, https://quartopub.com/, etc.).


## Données atelier

**Vecteur**

-   [OpenStreetMap](https://www.openstreetmap.org/) (POI) : restaurants.
-   Le découpage géographique des municipalités québécoises (Source : [Ministère des Ressources naturelles et des Forêts](https://mrnf.gouv.qc.ca/repertoire-geographique/carte-generale-base-donnees-geographiques-administratives/)).
-   La série de population 2001-2022 et l'indice de vitalité économique des localités québecoises, délivré par l'[Institut de la Statistique du Québec](https://statistique.quebec.ca/fr/recherche?territoire=municipalites&type_produit=tableau-detaille).

**Raster** 

- Couverture du sol : [Comptes des terres du Québec Méridional](https://www.donneesquebec.ca/recherche/fr/dataset/comptes-des-terres-du-quebec-meridional-changement-de-la-couverture-terrestre) (années de capture entre 2002 et 2013 selon les régions administratives).


::: {.callout-caution}
## Télécharger les données de l'exercice

Toutes les données mobilisées dans cet atelier son stockées dans un projet RStudio. Vous devez le télécharger puis le décompresser sur votre machine. Il vous sera ensuite possible de tester l'ensemble des manipulations proposées dans ce document au sein du projet **quebec**.  
[Télécharger le projet](quebec.zip){.btn .btn-primary .btn-sm role="button"}  

:::

## Préparation des données

Dans cet atelier nous allons utiliser des données portant sur les municipalités du Québec. Dans un premier temps nous avons préparé et nettoyé les données avec le logiciel R. 
Les différentes étapes de préparation sont décrites dans le script suivant.  

```{r}
#| eval: false
#| code-fold: true
library(sf)
library(mapsf)
library(readxl)
library(rmapshaper)

# Communes
mun <- st_read("data-raw/munic_s.shp", quiet = TRUE)
# Transformation conique équivalente d'ALbers
mun <- st_transform(mun, 6623)
# Suppression des surfaces en eau
mun <- mun[!is.na(mun$MUS_CO_GEO),]
# Selection des variables pertinentes
mun <- mun[, c("MUS_CO_GEO", "MUS_NM_MUN", "MUS_CO_MRC", "MUS_NM_MRC", "MUS_NM_REG")]
# Simplifier les contours des polygones
mun <- ms_simplify(mun, )

# Agregation des multipolygones
mun <- aggregate(x = mun[, -1], 
                 by = list(MUS_CO_GEO = mun$MUS_CO_GEO),
                 FUN = head, 1)
mun <- st_cast(mun, "MULTIPOLYGON")

# Import données population et nettoyage
df <- read_xlsx("data-raw/stats_socio_eco/Pop-MUN-total.xlsx", 
                skip = 3, n_max = 1292,
                col_types = c(rep("text", 2),"numeric",rep("text", 4), 
                              rep("numeric", 22))) 
df <- as.data.frame(df)
df <- df[,c(1:3, 8:29)]
col_pop <- paste0("POP_", seq(2001, 2022, 1))
colnames(df) <- c("NOM", "STATUT", "MUS_CO_GEO", col_pop)
df$MUS_CO_GEO <- formatC(df$MUS_CO_GEO, width = 5, flag = "0", format = "d")

mun <- merge(mun, df, by = "MUS_CO_GEO", all.x = T)


# Import données socio-éco et nettoyage
df2 <- data.frame(read_xlsx("data-raw/stats_socio_eco/Tableau.xlsx", 
                            skip = 4, n_max = 1163))
df2 <- df2[-c(1:2),]
df2 <- df2[,c(2:4,6,8,10)]
colnames(df2) <- c("NOM", "REG", "VIT_ECO", "REV_MED", "TX_2564", "TAAM")
df2$id <- paste0(df2$NOM, "_", df2$REG)

df2$VIT_ECO <- as.numeric(df2$VIT_ECO)
df2$REV_MED <- as.numeric(df2$REV_MED)
df2$TX_2564 <- as.numeric(df2$TX_2564)
df2$TAAM <- as.numeric(df2$TAAM)
mun$id <- paste0(mun$NOM, " (", mun$STATUT, ")_", mun$MUS_NM_REG)
mun <- merge(mun, df2, by = "id", all.x = TRUE)
mun <- mun[, c(2:6, 8:30, 33:36)]



# agregation de municipalité en Municipalité régionale de comté (MRC)
mun <- st_set_precision(mun, 1)
mrc <- aggregate(mun[, c("MUS_NM_MRC","MUS_NM_REG")], 
                 by = list(MUS_CO_MRC = mun$MUS_CO_MRC),
                 FUN = head, 1)
mrc <- st_cast(mrc, "MULTIPOLYGON")
mun <- st_set_precision(mun, 0)

st_write(st_transform(mrc, 4326), "data/mrc.geojson")
st_write(st_transform(mun, 4326), "data/munic.geojson")
```

Ce script abouti à la création de deux fichiers :

- `mrc.geojson` est un fond de carte des Municipalité Régionales de Comté. 
- `munic.geojson` et un fond de carte des municipalités contenant des données socio-démographiques. 


# R

## L'écosystème spatial de R

Le logiciel R [@R-base] permet depuis longtemps de traiter et représenter les données spatiales.  
Le principal package permettant de traiter les données vectorielles avec R est le package `sf` [@R-sf].  
Les packages `stars` [@pebesma2023] et `terra` [@R-terra] quand à eux sont les principaux packages dédiés au traitement des données raster.

Les développements actuels s'appuient sur ce socle et forment un écosystème robuste qui offre aux utilisateurs la plupart des fonctionnalités autrefois réservées aux Systèmes d'Information Géographique.  
Le package `mapsf` [@R-mapsf] par exemple s'appuie sur le package `sf` pour créer des cartes thématiques. D'autres packages sont dédiés à la cartographie interactive, aux statistiques spatiales, l'interaction avec des API de cartographie, la création de cartogrammes etc.

## Le package `sf`

<img src="fig/logo_sf.gif" align="right" width="150"/>

Le package `sf` a été publié fin 2016 par Edzer Pebesma. Ce package permet l'import, l'export, la manipulation et l'affichage de données spatiales vectorielles. Pour cela `sf` s'appuie sur une série de bibliothèques spatiales : GDAL [@GDAL] et PROJ [@PROJ] pour les opérations d'import, d'export et de projection, et GEOS [@GEOS] pour les opérations de géotraitement (buffer, intersection...).  
Ce package propose des objets simples (suivant le standard [*simple feature*](https://en.wikipedia.org/wiki/Simple_Features)) dont la manipulation est assez aisée. Une attention particulière a été portée à la compatibilité du package avec la syntaxe *pipe* (`|>` ou `%>%`) et les opérateurs du `tidyverse` [@R-tidyverse].

![@pebesma2023](fig/sf_deps.png)

::: callout-note
## Historique

Le package `sf` est venu remplacer les packages `sp` [@R-sp], `rgeos` [@R-rgeos] et `rgdal` [@R-rgdal] en combinant leurs fonctionnalités dans un package unique plus ergonomique.
:::

::: panel-tabset
```{r knit_init}
#| include: false
#| cache: false
knitr::knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  } 
})
knitr::opts_chunk$set(nm=TRUE, echo=TRUE)
```

### Format

![Format des objets spatiaux `sf`](fig/sf.png)

Les objets `sf` sont des `data.frame` dont l'une des colonnes contient des géométries.  
Ce format est très pratique dans la mesure ou les données et les géométries sont intrinsèquement liées dans un même objet.

::: callout-note
## Vignette décrivant le format simple feature

[Simple Features for R](https://r-spatial.github.io/sf/articles/sf1.html)
:::

### Import

```{r sf_import_fake}
#| eval: false
library(sf)
mtq <- st_read(dsn = "data/mtq.gpkg", layer = "mtq")
```

```{r sf_import}
#| include: false
library(sf)
library(mapsf)
mtq <- mf_get_mtq()
```

### Affichage

```{r sf_plot, fig.height=3, fig.width=3, nm=TRUE}
plot(st_geometry(mtq))
```

```{r sf_plot_multi, fig.height=4, fig.width=7, nm=TRUE}
plot(mtq)
```

### Centroides

```{r sf_centro,  fig.height=3, fig.width=3, nm=TRUE, warning=FALSE}
mtq_c <- st_centroid(mtq)
plot(st_geometry(mtq))
plot(st_geometry(mtq_c), cex = 1.2, col = "red", pch = 20, add = TRUE)
```

### Matrice de distance

```{r sf_matrix,  fig.height=3, fig.width=3, nm=TRUE}
mat <- st_distance(x = mtq_c, y = mtq_c)
mat[1:5, 1:5]
```

### Agéregation

```{r sf_agg,  fig.height=3, fig.width=3, nm=TRUE}
mtq_u <- st_union(mtq)
plot(st_geometry(mtq), col = "lightblue")
plot(st_geometry(mtq_u), lwd = 2, border = "red", add = TRUE)
```

### Zone tampon

```{r sf_buff,  fig.height=3, fig.width=3, nm=TRUE}
mtq_b <- st_buffer(x = mtq_u, dist = 5000)
plot(st_geometry(mtq_b), col = "grey", lwd = 2, border = "red")
plot(st_geometry(mtq), col = "lightblue", add = TRUE)
plot(st_geometry(mtq_u), lwd = 2, add = TRUE)
```

### Intersection

```{r sf_interse,  fig.height=3, fig.width=3, nm=TRUE, echo=FALSE}
m <- rbind(c(700015,1624212), c(700015,1641586), 
           c(719127,1641586), c(719127,1624212), 
           c(700015,1624212))
p <- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq))
plot(st_geometry(mtq))
plot(p, border="red", lwd=2, add=T)
text(719127,1641586, "p", pos = 4, cex = 3)
```

```{r sf_intersect2,  fig.height=3, fig.width=3, nm=TRUE, warning=F}
#| layout-ncol: 2
mtq_z <- st_intersection(x = mtq, y = p)
plot(st_geometry(mtq))
plot(st_geometry(mtq_z), col = "red", border = "green", add = TRUE)
plot(st_geometry(mtq_z), lwd = 2)
```

### Polygones de Voronoi

```{r sf_voronoi,  fig.height=3, fig.width=3, nm=TRUE}
mtq_c |> 
  st_union() |> 
  st_voronoi() |> 
  st_collection_extract("POLYGON") |> 
  st_intersection(mtq_u) |> 
  st_sf() |> 
  st_join(mtq_c, st_intersects) |>
  st_cast("MULTIPOLYGON") |>
  st_geometry() |>
  plot(col = "ivory4")
```
:::


## Le package `mapsf`

<img src="fig/logo_mapsf.png" align="right" width="150px"/>

`mapsf` permet de créer la plupart des types de carte utilisés habituellement en cartographie statistique.  
Pour chaque type de carte, plusieurs paramètres permettent de personnaliser la représentation cartographique. Ces paramètres sont les mêmes que ceux que l'on retrouve dans les logiciels de SIG ou de cartographie usuels.  
Associées aux fonctions de représentation des données d'autres fonctions sont dédiées à l'habillage cartographique, à la création de cartons ou à l'export des cartes.  
`mapsf` est le successeur de [`cartography`](http://riatelab.github.io/cartography/docs/) [@R-cartography], il offre les mêmes fonctionnalités principales tout en étant plus léger et plus ergonomique.

![Chaîne de traitement typique](fig/workflow.png)

::: panel-tabset
### Types de carte

::: {layout="[[1,1,1], [1,1,1]]"}
![](fig/map01.png)

![](fig/map02.png)

![](fig/map03.png)

![](fig/map04.png)

![](fig/map05.png)

![](fig/map06.png)

![](fig/map07.png)

![](fig/map08.png)

![](fig/map09.png)
:::

### Utilisation simple

```{r mapsf_simple}
#| fig-width: 5
#| fig.height: 6
library(mapsf)
# Import the sample dataset
mtq <- mf_get_mtq()
# Plot the base map
mf_map(x = mtq)
# Plot proportional symbols
mf_map(x = mtq, var = "POP", type = "prop")
# Plot a map layout
mf_layout(title = "Population in Martinique", 
          credits = "T. Giraud; Sources: INSEE & IGN, 2018")
```

### Utilisation avancée

```{r mapsf_avance}
#| results: hide
# Export a map with a theme and extra margins 
mf_export(x = mtq, filename = "fig/mtq.svg",  width = 5, 
          theme = "green", expandBB = c(0,0,0,.3)) 
# Plot a shadow
mf_shadow(mtq, col = "grey10", add = TRUE)
# Plot a choropleth map
mf_map(x = mtq, var = "MED", type = "choro",
       pal = "Dark Mint", 
       breaks = "quantile", 
       nbreaks = 6, 
       leg_title = "Median Income\n(euros)", 
       leg_val_rnd = -2, 
       add = TRUE)
# Start an inset map
mf_inset_on(x = "worldmap", pos = "right")
# Plot mtq position on a worldmap
mf_worldmap(mtq, col = "#0E3F5C")
# Close the inset
mf_inset_off()
# Plot a title
mf_title("Wealth in Martinique, 2015")
# Plot credits
mf_credits("T. Giraud\nSources: INSEE & IGN, 2018")
# Plot a scale bar
mf_scale(size = 5)
# Plot a north arrow
mf_arrow('topleft')
dev.off()
```

![](fig/mtq.svg){width="500px"}

```{r reset_theme}
#| include: false
mf_theme("default")
```
:::

::: callout-note
D'autres packages peuvent être utilisés pour réaliser des cartes thématiques.  
Le package `ggplot2` [@R-ggplot2], en association avec le package `ggspatial` [@R-ggspatial], permet par exemple d'afficher des objets spatiaux et de réaliser des cartes thématiques simples.  
Le package `tmap` [@R-tmap] est dédié à la création de cartes thématiques, il utilise une syntaxe proche de celle de `ggplot2` (enchaînement d'instructions combinées avec le signe `+`).  
La documentation et les tutoriels pour utiliser ces deux packages sont facilement accessibles sur le web.
:::

## Ressources

[Geocomputation with R](https://r.geocompx.org/) - @lovelace2019

[Spatial Data Science with applications in R](https://r-spatial.org/book/) - @pebesma2023

[Spatial Data Science with R and "terra"](https://rspatial.org/) - Robert J. Hijmans

[Progress in the R ecosystem for representing and handling spatial data](https://link.springer.com/article/10.1007/s10109-020-00336-0) - @bivand2021

[Cartographie avec R](https://rcarto.github.io/cartographie_avec_r/) - @Giraud_Cartographie_avec_R_2023

[Géomatique avec R](https://rcarto.github.io/geomatique_avec_r/) - @Giraud_Geomatique_avec_R_2023

[CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html)

[R Special Interest Group on using Geographical data and Mapping](https://stat.ethz.ch/mailman/listinfo/r-sig-geo) (mailing list)

## Exemples d'analyse sur les données du Québec

### Import et préparation des données

Nous utilisons le package `sf` pour importer 2 fichiers geojson.  
Il est ensuite possible de changer la projection des couches avec la fonction `st_transform()`.  
Nous pouvons aussi créer une couche des régions du Québec en agrégeant les Municipalité Régionales de Comté.

```{r import}
#| message: false
# Import des données
library(sf)
mun_raw <- st_read("data/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("data/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
epsg_6623 <- "EPSG:6623"
mun <- st_transform(mun_raw, epsg_6623)
mrc <- st_transform(mrc_raw, epsg_6623)
# Création d'une couche des régions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
```

### Première cartographie simple

Sur cette première carte nous allons simplement afficher les différentes couches en les superposant.  
Nous utilisons le package `mapsf` qui permet aussi de créer une couche d'étiquettes avec la fonction `mf_label()`.

```{r carto_quebec_reg}
#| fig-width: 8
#| fig-height: 10.05
library(mapsf)
mf_map(mun, border = "white")
mf_map(mrc, col = NA, border = "grey70", lwd = 1, add = TRUE)
mf_map(reg, col = NA, border = "black", lwd = 1.2, add = TRUE)
mf_label(reg, var = "MUS_NM_REG", halo = TRUE, overlap = FALSE)
mf_scale(size = 100)
mf_title("Le Québec")
mf_credits(txt = "Ministère des Ressources naturelles et des Forêts, 2023", 
           bg = "#ffffffCC")
```

### Où sont les restaurants dans la ville de Québec?

Nous voulons savoir dans quelles zones de la ville de Québec se trouvent les restaurants.  
Pour connaître la position des restaurants dans la ville nous allons extraire des informations la base de donnés cartographique libre OpenStreetMap avec le package `osmdata` [@R-osmdata]. Le package `osmdata` utilise l'API du service [Overpass turbo](https://overpass-turbo.eu/) pour extraire des données vectorielles de la base de données OpenStreetMap.

Nous devons tout d'abord définir une emprise spatiale à partir de laquelle nous pourrons extraire les informations sur les restaurants.  
Après avoir démarré les packages nécessaires, nous allons tout d'abord sélectionner la MRC de Québec dans la couche des MRC.

```{r target_city}
#| message: false
library(sf)
library(osmdata)
nom_mrc <- "Québec"
target <- mrc[mrc$MUS_NM_MRC == nom_mrc, ]
```

Nous allons ensuite définir une *bounding box* correspondant à l'emprise de la MRC. Le package `osmdata` fonctionne avec des objets en WGS84 nous avons donc besoin de reprojeter les données.

```{r create_bb}
# Reprojection en WGS84
target_4326 <- st_transform(target, "EPSG:4326")
# Création de la bounding box
bbox <- st_bbox(target_4326)
```

Nous pouvons maintenant définir ce que nous voulons extraire de la base de donnée OSM. Une connaissance de la structuration de la base de données OSM est nécessaire ([Wiki OpenStreetMap](https://wiki.openstreetmap.org/wiki)). Nous utilisons le système de clef/valeur pour construire la requête.

```{r define_request}
# Initialisation de la requête à envoyer
q <- opq(bbox = st_bbox(bbox))
# Choix des objets à extraire
req <- add_osm_feature(opq = q, 
                       key = 'amenity', 
                       value = "restaurant")


```

La fonction `osmdata_sf()` permet d'envoyer la requête et de recevoir les résultats sous forme de `data.frame` `sf`.

```{r send_request}
#| cache: true
# Reception de la requete
res <- osmdata_sf(q = req)
res
```

Ce résultat contient des restaurants représentés par de points (*osm_points*) et d'autre représentés par des polygones (*osm_polygons*). La couche des points contient également les points qui composent les polygones de la couche de polygones. La fonction `unique_osmdata()` permet de filtrer ces "doublons".

```{r filter_osm}
# Reduction du resultats 
# (les points composant les polygones sont supprimés)
res <- unique_osmdata(res)
res
```

L'étape suivante consiste à utiliser extraire les points et les polygones, puis à extraire les centroides des polygones pour constituer une couche de points complète.

```{r build_layer}
#| warning: false
# Extraction des points
resto_point <- res$osm_points
# Extraction des polygones
resto_poly <- res$osm_polygons
# Transformation des polygones en points (centroides)
resto_poly_point <- st_centroid(resto_poly)
# Listes des champs à conserver
chps <- c("osm_id", "name", "cuisine")
# Rassembler les 2 couches de points
resto <- rbind(resto_point[, chps], resto_poly_point[, chps])
resto
```

Maintenant que nous avons cette couche de restaurants nous allons pouvoir l'afficher.  
Pour cela nous pouvons utiliser un fond de carte issues de tuiles raster grâce au package `maptiles` [@R-maptiles]. Nous allons d'abord reprojeter les différentes couches d'information en Web/Mercator (EPSG:3857) car les tuiles raster sont fournies dans cette projection .

```{r reproj_layers}
target <- st_transform(target, "EPSG:3857")
resto <- st_transform(resto, "EPSG:3857")
```

Nous pouvons maintenant télécharger les tuiles raster grace à la fonction `get_tiles()`.

```{r get_tiles}
library(maptiles)
tiles <- get_tiles(x = target, 
                   provider = "CartoDB.PositronNoLabels",
                   project = FALSE, 
                   crop = TRUE, 
                   zoom = 11)
```

Nous créons ensuite la carte avec `mapsf`.

```{r resto_map1}
#| results: hide
library(mapsf)
mf_theme(mar = c(0,0,0,0), inner = TRUE)
mf_export(x = tiles,
          filename = "fig/restaurants01.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, col = NA, lwd = 2, add = TRUE)
mf_map(resto, col = "red", add = TRUE)
mf_title("Les restaurants à Québec")
mf_credits("© OpenStreetMap contributors © CARTO", bg = "white")
dev.off()
```

![](fig/restaurants01.png)

Nous allons maintenant agréger les restaurants dans une grille régulière pour tenter rendre plus lisible l'organisation spatiale des restaurants à Québec.

```{r grid}
#| results: hide
# Création d'une grille régulière (carreaux : 2km * 2km)
grid <- st_make_grid(target, cellsize = 2000)
grid <- st_sf(id = 1:length(grid), geom = grid)

# Comptage des points dans les polygones
grid$n <- lengths(st_intersects(grid, resto, sparse = TRUE))

# Cartographie
mf_export(x = tiles,
          filename = "fig/restaurants02.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, col = NA, lwd = 2, add = TRUE)
mf_map(x = grid[grid$n >0 , ], 
       var = "n", 
       type = "choro", 
       breaks = 'geom', 
       nbreak = 6, 
       alpha= .75, 
       border = NA, 
       pal = "Burg", 
       leg_frame = TRUE, 
       leg_pos = "left", 
       leg_title = "Nombre de restaurants",
       leg_val_rnd = 0,
       add = TRUE)
mf_title("Les restaurants à Québec")
mf_credits("© OpenStreetMap contributors © CARTO", bg = "white")
dev.off()
```

![](fig/restaurants02.png)

Nous pouvons aussi utiliser une méthode de lissage telle que la méthode de lissage par noyaux (KDE) grâce au package `spatstat` [@R-spatstat].

```{r kde}
#| results: hide
#| message: false
#| warning: false
library(spatstat)
library(terra)
library(tanaka)
p <- as.ppp(st_coordinates(resto), W = as.owin(st_bbox(target)))
# portée du lissage 500m
ds <- density.ppp(p, sigma = 500, eps = c(100, 100), positive = TRUE)
# transformation en raster terra et passage en unité par km²
rasdens <- rast(ds) * 1000 * 1000
# ajout des information de projection
crs(rasdens) <- 'EPSG:3857'
# affichage par défaut
plot(rasdens)
```

Il est ensuite possible de représenter les densités calculées avec les packages `tanaka` [@R-tanaka] et `mapsf`.
```{r kde2}
# Calcul des polygones de contour en fonction de bornes de classe
iso <- tanaka_contour(rasdens, breaks = c(1,2,5,10,20,25))
# choix d'une palette de couleur
cols <- mf_get_pal(n = 5, palette = "Teal", rev = TRUE)
# selection des région ou la densité est >= 1
iso <- iso[-1, ]
# Cartographie
mf_export(x = tiles,
          filename = "fig/restaurants03.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, add = T, col = NA, lwd = 2)
tanaka(iso, 
       legend.title = "Nombre de\nrestaurants\nau km²\n(KDE, sigma=500)",
       legend.pos = "topright", 
       shift = 65,
       col = cols,
       add = TRUE)
mf_title("Les restaurants à Québec")
mf_credits("© OpenStreetMap contributors © CARTO",bg = "white")
dev.off()
```

![](fig/restaurants03.png)


## À vous de jouer

- Vous devez étudier la répartition des restaurants dans une autre MRC, par exemple celle de Montréal. 

- Vous devez étudier la répartition des bars et pubs à Québec (dans OpenStreetMap key = "amenity", value = "pub" et value = "bar"). 


Pour cela vous devrez construire un document quarto (au format de votre choix) et adapter quelques passage du code présenté précédemment. 











# Python


```{r reticulate-env}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```

```{python pandas-column-width-setup}
#| echo: false
import pandas as pd
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
```




## Le langage Python

:::: columns
::: {.column width="70%"}
- **Python** : un langage *polyvalent*, *interprété* et *multi-paradigme*

- De plus en plus utilisé pour la *science des données*

:::{.fragment}
- Un écosystème robuste pour différents domaines d'application scientifiques

![](./fig/python-stack.png)
:::

:::

::: {.column width="30%"}
![](./fig/logo-python.png)

:::
::::

## Écosystème pour le géospatial

## Données vectorielles

-   [**Bindings Python de GDAL/OGR**](https://gdal.org/api/python_bindings.html) [@GDAL]
-   [**Fiona**](https://fiona.readthedocs.io/en/stable/) [@fiona] - I/O (*wrapper* de haut niveau autour d'OGR)
-   [**Shapely**](https://shapely.readthedocs.io/)  [@sgillies_2023] - bindings Python de [GEOS](https://github.com/libgeos/geos) [@GEOS]
-   [**Pyproj**](https://pyproj4.github.io/pyproj) [@pyproj] - bindings Python de [PROJ](https://proj.org/) [@PROJ]
-   [**Geopandas**](https://geopandas.org/)  [@kelsey_jordahl_2020_3946761] - Étend les `DataFrame`s de [pandas](https://pandas.pydata.org/) [@pandas]

![](./fig/logo-pandas.svg)

![](./fig/logo_geopandas.svg)

## Le package *GeoPandas*

Un projet open source pour faciliter le travail avec des données géospatiales vectorielles en Python. GeoPandas étend Pandas pour permettre de disposer d'un type de colonne géométrique et pour permettre d'effectuer des opérations spatiales. Les opérations géométriques sont réalisées avec `shapely`, les accès en lecture / écriture aux fichiers utilisent `fiona` et la visualisation utilise `matplotlib`.

![Format des GeoDataFrame](./fig/geopandas-table.png)

- Utilisation :

::: {.panel-tabset .custom-tab}

### Import et lecture

```{python gpd-tuto-import-1}
#| echo: false
import geodatasets

file_path = geodatasets.get_path("nybb")
```

Avec la fonction `read_file` :

```{python gpd-tuto-import-2}
import geopandas as gpd

nybb = gpd.read_file(file_path)
```

### Affichage

Avec la méthode `plot` des `GeoDataFrame` :

```{python gpd-tuto-plot}
nybb.plot()
```

### SCR

Affichage :

```{python gpd-tuto-crs}
print(nybb.crs)
```

Transformation :

```{python gpd-tuto-transformation}
nybb_geo = nybb.to_crs('EPSG:4326')
```

### Affichage avec fond de carte

En utilisant la bibliothèque `contextily` :

```{python gpd-tuto-contextily}
import contextily as cx

ax = nybb.to_crs('EPSG:3857').plot()
cx.add_basemap(ax, source='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png')
ax.set_axis_off()
ax
```

### Centroide

Simplement en utilisant l'attribut `centroid` des `GeoDataFrame` :

```{python gpd-tuto-centroid}
nybb.centroid.plot()
```

### Boundary

Simplement en utilisant l'attribut `boundary` des `GeoDataFrame` :

```{python gpd-tuto-boundary}
nybb.boundary.plot()
```

### Zone tampon

En utilisant la méthode `buffer` des `GeoDataFrame` :

```{python gpd-tuto-buffer}
buff_nybb = nybb.buffer(3000)
```

```{python gpd-tuto-buffer-2}
ax = buff_nybb.plot(color="red")
nybb.plot(ax=ax, color="aliceblue")
```


### Aggrégation

En utilisant la méthode `dissolve` des `GeoDataFrame` :

```{python gpd-tuto-agg}
# On peut utiliser dissolve(by="nom_colonne") si on veut aggréger selon les valeurs d'une colonne
agg = nybb.dissolve()
agg.plot()
```


### Intersection

En utilisant la méthode `intersection` des `GeoDataFrame` :

```{python gpd-tuto-intersection}
from shapely import wkt

point = wkt.loads('Point(998769.1146889535 174169.7607268664)')

intersecting = nybb.intersection(point.buffer(35000))
```

<br>

```{python gpd-tuto-intersectiob-2}
ax = nybb.plot()
ax = intersecting.plot(ax=ax, color="red")
ax
```

:::

## Données raster

-   [**Rasterio**](https://rasterio.readthedocs.io/) [@gillies_2019] :
    * lecture / écriture de raster (*wrapper* de haut niveau autour de GDAL)
    * données représentées sous forme d'`array` NumPy
    * reprojection
    * _resampling_
    * _virtual files_
    * etc.

-   [**Rasterstats**](https://pythonhosted.org/rasterstats/) :
    * résumer des données raster sur la base de géométries vectorielles
    * extraction de valeurs à un point précis

-   [**xarray**](https://docs.xarray.dev/en/stable/) [@xarray] et [**rioxarray**](https://corteva.github.io/rioxarray/) [@rioxarray]:
    * *xarray* pour travailler avec des tableaux multidimensionnels étiquetés
    * *rioxarray* pour ouvrir des jeux des données raster avec *rasterio*, les stocker dans le format de *xarray*, et avoir accès à différentes fonctionnalités de *rasterio*
    * moins "rustique" que d'utiliser rasterio seul / dépend de l'usage souhaité

## Le package *Rasterio*

Exemple d'utilisation :

```{python example-rio-1}
import rasterio as rio

with rio.open('./data/MODIS_ARRAY.nc') as f:
    # Métadonnées :
    metadata = f.meta
    # Lire toutes les bandes :
    data = f.read()
    # Ou f.read(1) pour lire seulement la première bande
```

- Un dictionnaire de méta-données + un tableau NumPy contenant la (ou les) bande(s) :

```{python example-rio-2}
print(metadata)
print(data)
```

## Les package *xarray* et *rioxarray*

Exemple d'utilisation :

::: {.panel-tabset .custom-tab}

### Import et lecture

```{python xarray-tuto-import-1}
import rioxarray
import xarray

xds = xarray.open_dataarray("./data/MODIS_ARRAY.nc")
```

- Un objet de type `xarray.DataArray` ou `xarray.Dataset` qui contient les différentes méta-données et les données :

```{python xarray-tuto-import-2}
xds
```

### Complétion des valeurs manquantes

```{python xarray-tuto-na}
filled = xds.rio.interpolate_na()
```

### Affichage

En utilisant la méthode `plot` des objets `xarray.DataArray` (ici après avoir sélections un *subset* des données) :

```{python xarray-tuto-plot}
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(15, 5))
ax1, ax2 = (fig.add_subplot(131), fig.add_subplot(133))

xds.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax1)
filled.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax2)
```

### SCR

- Affichage :

```{python xarray-tuto-crs-1}
xds.rio.crs
```

- Transformation :

```{python xarray-tuto-crs-2}
xds = xds.rio.reproject("EPSG:6623")
```

### Découpage

- Découpage selon l'emprise des données contenues dans un `GeoDataFrame` (ici `gdf`) :

```{python xarray-tuto-clipping}
#| eval: false
clipped = xds.rio.clip(gdf.geometry.values, gdf.crs, drop=False, invert=True)
```

:::


## Analyse spatiale

:::: {.columns}

::: {.column width="80%"}

Écosystème de bibliothèques pour l'analyse spatiale [PySAL](https://pysal.org/) (Python Spatial Analysis Library, @pysal2007) :

- **Explorer**:
  - Analyse exploratoire des données spatiales (package [esda](https://pysal.org/esda/))
  - Analyse de la dynamique des données spatiales longitudinales (package [giddy](https://pysal.org/giddy/))
  - Mesure des inégalités dans l'espace et dans le temps (package [inequality](https://inequality.readthedocs.io/en/latest/))
  - Analyse statistique de motifs ponctuels planaires (package [pointpats](https://pysal.org/pointpats/))
  - Mesure de la ségrégation dans le temps et dans l'espace (package [segregation](https://pysal.org/segregation/))
  - Morphométrie urbaine (package [momepy](https://docs.momepy.org/en/stable/))

- **Modéliser**:
  - Régression géographiquement pondérée à plusieurs échelles (package [mgwr](https://mgwr.readthedocs.io/en/latest/))
  - Modèles linéaires généralisés épars (package [spglm](https://spglm.readthedocs.io/en/latest/))
  - Modèles d'interaction spatiale (package [spint](https://spint.readthedocs.io/en/latest/))
  - Modèles de régression spatiale (package [spreg](https://spreg.readthedocs.io/en/latest/))
  - Modèles de composantes de variance à corrélation spatiale à plusieurs niveaux (package [spvcm](https://github.com/pysal/spvcm))
  - *Areal interpolation* et cartographie dasymétrique (package [tobler](https://pysal.org/tobler/))
  - Accessibilité spatiale (package [access](https://pysal.org/access/))
  - Optimisation spatiale (package [spopt](https://pysal.org/spopt/))

:::

::: {.column width="20%"}

![](./fig/logo-pysal.png)
:::

::::


## Autres packages utiles ...

-   Binding Python pour [GRASS](https://grass.osgeo.org/grass82/manuals/libpython/index.html) + Intégration dans les notebooks Jupyter

![Source: <https://grass.osgeo.org/news/2022_06_05_results_student_grant_caitlin/>](./fig/grass_jupyter_combo_vis.png)

- [Iris](https://scitools-iris.readthedocs.io/en/stable/)

- Pour la cartographie : [cartopy](https://scitools.org.uk/cartopy/docs/latest/) ; [geoviews](https://geoviews.org/) et [geoplot](https://residentmario.github.io/geoplot/) basés sur *cartopy* ; [PyGMT](https://www.pygmt.org/latest/) (selon les usages - pas de solution aussi aboutie que `mapsf` pour les cartes réalisées en SHS).

![](./fig/cartopy.png)

## Ressources Python Géospatial

- [https://py.geocompx.org/](https://py.geocompx.org/) [@Dorman2022]

- [https://geo-python-site.readthedocs.io/en/latest/](https://geo-python-site.readthedocs.io/en/latest/)

- [https://automating-gis-processes.github.io](https://automating-gis-processes.github.io)

- [https://www.earthdatascience.org/courses/use-data-open-source-python/](https://www.earthdatascience.org/courses/use-data-open-source-python/)

- [https://geographicdata.science/book/intro.html](https://geographicdata.science/book/intro.html)


## Interaction R ⇄ Python dans Quarto

::: {.panel-tabset}

### R → Python

- Définition de variables dans un chunk R :

```{r example-r-1}
a <- 42
b <- list(1, 2, 3)
c <- c(12, 13, 14)
```

- Récupération depuis un chunk Python :

*en utilisant la variable `r`, un point, et le nom de la variable R à récupérer*

```{python example-python-1}
print(r.a)
print(r.b)
print(r.c)
```


### Python → R

- Définition de variables dans un chunk Python :

```{python example-python-2}
a = 42
b = [1, 2, 3]
```

- Récupération depuis un chunk R :

*en utilisant la variable `py`, un dollar `$`, et le nom de la variable Python à récupérer*

```{r example-r-2}
print(py$a)
print(py$b)
```


:::

## Interaction R ⇄ Python dans Quarto (suite)

- Il est possible d'échanger des types plus complexes (`data.frame` ⇄ `DataFrame` pandas, tableau numpy, etc.)


::: {.panel-tabset}

### R → Python

- Depuis un chunk R :

```{r example-r-3}
df <- data.frame(
   emp_id = c(1:5),
   emp_name = c("Rick","Dan","Michelle","Ryan","Jane"),
   salary = c(623.3,515.2,611.0,729.0,843.25),
   start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27")),
   stringsAsFactors = FALSE
)
```

- Récupération depuis un chunk Python :

```{python example-python-3}
df = r.df
print(df.head())
```


### Python → R

- Depuis un chunk Python :

```{python example-python-4}
import pandas as pd
import numpy as np

df2 = pd.DataFrame({
  "emp_id": list(range(5)),
  "emp_name": ["Rick", "Dan", "Michelle", "Ryan", "Jane"],
  "salary": [623.3, 515.2, 611.0, 729.0, 843.25],
  "start_date": pd.to_datetime(["2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27"]),
})

arr = np.array([[12, 47], [34, 90], [23, 19]])
```

- Utilisation depuis un chunk R :

```{r example-r-4}
head(py$df2)
print(py$arr)
```

:::

## Interaction R ⇄ Python dans Quarto (suite)

Et pour les objets spatiaux ? (*sf* / *geopandas*)

- Si la conversion `data.frame` ⇄ `DataFrame` est transparente, il n'en est pas de même pour les dataframe avec une composante spatiale (perte de la dimension spatiale / colonne `geometry` contient désormais ...)

- L'écriture d'une petite function permet de résoudre ça :

```{r import-py}
#| message: false
#| echo: false
#| eval: false
# Import des données
library(sf)
mun_raw <- st_read("geom/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("geom/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
crs <- "EPSG:6623"
mun <- st_transform(mun_raw, crs)
mrc <- st_transform(mrc_raw, crs)
# Création d'une couche des régions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
resto_raw <- st_read('geom/resto.geojson', quiet = TRUE)
resto <- st_transform(resto_raw, crs)

sel <- "Québec"
```

```{python sf-gpd-conversion-function}
from shapely.geometry import shape
import geopandas as gpd

def restore_geodataframe(df, crs, geom_type):
  geom = df.geometry.apply(lambda coords: shape({ "type": geom_type, "coordinates": coords }))
  gdf = gpd.GeoDataFrame(df.drop(['geometry'], axis=1), geometry=geom)
  gdf.set_crs(crs, inplace=True)
  return gdf
```


Ainsi, les objets `sf` pourront être convertis en `GeoDataFrame` ainsi :

```{python sf-gpd-conversion-1}
mrc = restore_geodataframe(r.mrc, r.epsg_6623, "MultiPolygon")
mrc.head()
```

## Python, Quarto et interactivité

- Utilisation des widgets Jupyter possible (seulement is utilisation de l'engin de rendu `jupyter`, pas avec `knitr` - i.e. l'inverse des *htmlwidgets* en R qui ne fonctionne que si `knitr` est utilisé)

- Exemple :

![](./fig/example-quarto-jupyter-widgets.jpg)

- Documentation : [https://quarto.org/docs/interactive/widgets/jupyter.html](https://quarto.org/docs/interactive/widgets/jupyter.html)

## Exemples d'analyse sur les données du Québec

-   Les imports nécessaires :

```{python demo-import}
import numpy as np
import rasterio as rio
import pandas as pd
import geopandas as gpd
import rioxarray
import xarray

from rasterio.warp import calculate_default_transform, reproject, Resampling
from matplotlib import pyplot as plt
from rasterio.plot import show
from rasterio.mask import mask
from rasterstats import zonal_stats, point_query
```

-   On récupère les jeux de données et quelques autres infos (SRC, etc.) depuis l'environnement R :

```{python demo-vector-dataset-opening}
# Le SCR des données
dst_crs = r.epsg_6623

# On récupère le jeu de données "mrc" (municipalités régionales de comté)
# et le jeu de données "resto"
mrc = restore_geodataframe(r.mrc, dst_crs, "MultiPolygon")
resto = restore_geodataframe(r.resto, "EPSG:3857", "Point")
resto.to_crs(dst_crs, inplace=True)
reg = mrc.dissolve(by="MUS_NM_REG")

sel = r.nom_mrc # Québec

# Chemin du jeu de données raster
# et du fichier contenant les descriptions des catégories
lc_fp = './data/T01_PROVINCE.tif'
lc_categories_fp = './data/correspondance_raster_CL_COUV.dbf'
```

-   On extrait les entités correspondantes et on les affiche, relativement au reste de la province :

```{python demo-first-plot}
extract = mrc[mrc.MUS_NM_MRC == sel]

ax = mrc.plot(color="lightblue", edgecolor="grey", alpha=0.5, figsize=(16, 12))
ax = reg.plot(ax=ax, color=None, edgecolor="orange", alpha=0.8)
ax = extract.plot(ax=ax, color="red")
ax.set_axis_off()
ax
```

-   Ouverture et reprojection d'un jeu de données raster (avec *rioxarray*) :

```{python demo-open-raster}
xds = rioxarray.open_rasterio(lc_fp)
xds = xds.rio.reproject(dst_crs)
xds
```

- Affichons le raster reprojeté et l'emprise de la ville de Québec :

```{python demo-plot-raster}
# Remplacer les '255' par '0'
xds.data[xds.data == 255] = 0

# Étendue des données
bounds = xds.rio.bounds()
extent = [bounds[0], bounds[2], bounds[1], bounds[3]]

# Création d'une figure vide
fig, ax = plt.subplots(figsize=(16, 12))
# Affichage du raster (attribut 'data' de l'objet xds)
show(xds.data[0], ax=ax, extent=extent, cmap="Set3")
# Affichage de la ville de Québec en rouge par dessus
extract.plot(ax=ax, color='red', edgecolor='red', linewidth=2)
# On enlève l'affichage des axes
ax.set_axis_off()
ax
```

- Ouverture du fichier DBF qui contient les correspondances entre les codes et les noms des catégories d'utilisation des sols

```{python demo-open-dbf}
categories = pd.DataFrame(
  gpd.read_file(lc_categories_fp, encoding='utf-8')[['ID', 'CL_COUV', 'Descriptio']])
categories.head(11)
```

<br>

```{python demo-categories-mapping}
# On va convertir cette DataFrame en un dictionnaire pour l'utiliser
# comme un mapping ID -> Description
categories = {
  int(k): v['Descriptio']
  for k,v in categories[['ID', 'Descriptio']].set_index('ID').to_dict(orient='index').items()
}
# Bien qu'il y ait une catégorie 'Pas de données' (ID 10)
# certaines cellules ne comportent pas de valeur (nodata, ici avec la valeur 0)
categories[0] = 'Pas de données'
categories
```

-   Calculer les statistiques zonales (combien de cellules de chaque type dans la sélection) :

```{python demo-zonal-stats}
stats = zonal_stats(extract, xds.data[0], affine=xds.rio.transform(), categorical=True, nodata=0)
stats
```

-   Traçons un histogramme de ce résultat, en utilisant les noms appropriés des catégories d'utilisation des sols :

```{python demo-plot-zonal-stats}
#| output-location: slide
# Trier les valeurs par le nombre de cellule
sorted_values = sorted(stats[0].items(), key = lambda x: x[1], reverse=True)

# Utilise les noms de catégories du DataFrame `categories`...
x = [categories[int(k)] for k, _ in sorted_values]

# ...et les valeurs que nous venons de calculer avec la fonction `zonal_stats`
height = [v for _, v in sorted_values]

fig, ax = plt.subplots(figsize=(8, 8))
bar_container = ax.bar(x, height)
ax.set_xticklabels(
    ax.get_xticklabels(),
    rotation=45,
    horizontalalignment='right'
)
fig.tight_layout()
ax
```

- Dans quel type d'occupation du sol se trouvent les restaurants précédemment récupérés ?

```{python demo-resto-point-query}
geoms = resto['geometry'].tolist()

resto["lc"] = [categories[int(x)] for x in point_query(vectors=geoms, raster=xds.data[0], nodata=0, affine=xds.rio.transform())]
resto.head()
```

- Quels restaurants ne sont pas situés dans une zone artificialisée ?

```{python demo-resto-selection-1}
selection = resto[(resto.lc != 'Surfaces artificielles') & (resto.lc != 'Pas de données')]
selection
```


```{python demo-resto-selection-plot}
ax = extract.plot(color=None, edgecolor="black")
ax = selection.plot(ax=ax, marker='x', color='red', markersize=8)
ax.set_axis_off()
ax
```

## À vous de jouer 🚀

**Objectif** : Comparez l'occupation du sol de la MRC de Trois-Rivières à l'occupation du sol de la MRC de Montréal.

- Vous cherchez à obtenir :
    - un diagramme en barre (combinant le résultat des statistiques zonales pour la MRC de Trois-Rivières et pour la MRC de Montréal)
    - un résumé (pourquoi pas en HTML !) de la surface de chaque type d'occupation du sol, comme celui présenté en exemple ci-dessous, pour Trois-Rivières et Montréal

![Exemple de tableau de résumé](./fig/summary-lc.png)

- Au début de votre document, vous devez insérer un chunk de code `R` pour préciser la localisation de votre environnement virtuel Python - comme nous utilisons `knitr`, c'est ce qui va permettre à `reticulate` de savoir où chercher les packages Python qui ont été installés pour cet atelier :

````
```{{r}}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```
````

**_Besoin d'aide ?_**

::: {.callout-tip icon=false collapse="true"}
### Quelle suite d'action réaliser ?

- Créer un chunk 'r' pour dfinir la localisation de l'environnement virtuel
- Créer les chunks 'python' correspondants aux actions suivantes :
    - Ouvrir le jeu de données raster
    - Ouvrir le jeu de données vecteur
    - S'assurer qu'ils sont dans le même système de coordonnées de référence et effectuer la transformation si ce n'est pas le cas
    - Obtenir les statistiques zonales pour la MRC de Trois-Rivières
    - Obtenir les statistiques zonales pour la MRC de Montréal
    - Produire le diagramme et le tableau synthétisant ces informations

:::

::: {.callout-tip icon=false collapse="true"}
### De quelles bibliothèques a-t-on besoin ?


```{python help-import}
#| eval: false
import rioxarray
import xarray
import pandas as pd
import geopandas as gpd
import rasterstats
import matplotlib.pyplot as plt
```

:::

::: {.callout-tip icon=false collapse="true"}
### Besoin d'aide pour ouvrir les données raster ?


```{python help-xarray-opening}
#| eval: false
xds = xarray.open_dataarray("/chemin/vers/le/fichier")
```

:::

::: {.callout-tip icon=false collapse="true"}
### Besoin d'aide pour ouvrir les données vecteur ?


```{python help-gpd-opening}
#| eval: false
gdf = gpd.read_file('/chemin/vers/le/fichier')
```

:::

::: {.callout-tip icon=false collapse="true"}
### Comment connaitre la taille d'une cellule raster ?

En utilisant les paramètres décrivant la matrice de transformation de géoréférencement du jeu de données raster en question (cette transformation fait correspondre les coordonnées ligne/colonne des pixels aux coordonnées du système de référence de l'ensemble de données) :

```{python help-xarray-transform}
#| eval: false
transform = xds.rio.transform()
```

Puis en utilisant la première et la cinquième valeur qui représentent respectivement la largeur et la hauteur du pixel :

```{python help-xarray-pixel-size}
#| eval: false
area_pixel = transform[0] * abs(transform[4]) # la hauteur est généralement négative
```

:::

::: {.callout-tip icon=false collapse="true"}
### Comment faire pour qu'un *chunk* retourne du HTML ?

Par exemple en stockant du Markdown dans une chaîne de caractère et en le transformant en HTML avec `IPython.display.Markdown` :

```{python help-ipython-markdown}
#| eval: false
from IPython.display import Markdown

rendu = '''
## Résumé

| Catégorie | Superficie |
|---------|----------|
| Aahah | 21.34 |
'''

Markdown(rendu)
```

:::



# Observable JavaScript

![](fig/js.png){width="30%"}

## Qu'est-ce que l'ojs ?

L'<b>Observable javascript {ojs}</b> est un ensemble d'améliorations apportées à vanilla JavaScript créé par Mike Bostock (également auteur de D3 [@D3]). Observable JS se distingue par son exécution réactive, qui convient particulièrement bien à l'exploration et à l'analyse interactives des données. 

![](fig/d3.png){width="20%"} ![](fig/arrow.png){width="20%"} ![](fig/observable.png){width="20%"} <br/> **Observable** est aussi une startup fondée par Mike Bostock et Melody Meckfessel, qui propose une plateforme 100% en ligne (<https://observablehq.com>) pour concevoir, partager et diffuser des visualisations de données.

![](fig/frise.png)

**Observable** c'est donc aussi C'est aussi une [plateforme web](https://observablehq.com/) qui héberge des notebooks computationnels sur la visualisation de données.

![](fig/notebookobs.png)

**Objectifs**

👉 Construire un langage et un écosystème dédié à la visualisation de données sur le web

👉 Fédérer et faire collaborer une communauté

## Observable dans Quarto

Le runtime d'Observable est Open Source et est utilisé dans Quarto.

Dans Quarto, toutes les instructions s'écrivent dans des chunks {ojs}

``` {{ojs}}
```

On peut paramétrer l'affiche et/ou l'execution du code avec **//\| echo** et **//\| eval**.

``` {{ojs}}
//| echo: false
//| eval: true
```

*NB : Contrairement aux chunks R et Python, le code s'execute just in time dans le navigateur web une fois le notebook généré. Seul l'export html est donc pris en compte.*

## Principes

Le langage JavaScript n'a pas du été conçu pour l'analyse de données. Mais, gros point fort, on a tous un navigateur web et JavaScript tourne sur toutes les machines. Le but : bâtir une évolution du langage JavaScript pour en faire un langage adapté à l'analyse et la visualisation de données sur le web.

l'ojs ressemble donc à du JavaScript, mais il y a quelques différences.

### 👉 Des bibliothèques préchargées 📊

OJS c'est du JavaScript + plein de bibliothèques pré chargées : <br/>

| Symbol   | Name              | Version            |
|----------|-------------------|--------------------|
| \_       | Lodash            | 4.17.21            |
| aq       | Arquero           | \${aq.version}     |
| Arrow    | Apache Arrow      | 4.0.1              |
| d3       | D3.js             | \${d3.version}     |
| dot      | Graphviz          | 0.2.1              |
| htl      | Hypertext Literal | \${htl.version}    |
| Inputs   | Observable Inputs | \${Inputs.version} |
| L        | Leaflet           | \${L.version}      |
| mermaid  | Mermaid           | 9.1.6              |
| Plot     | Observable Plot   | \${Plot.version}   |
| SQLite   | SQL.js            | 1.7.0              |
| topojson | TopoJSON Client   | 3.1.0              |
| vl       | Vega, Vega-Lite   | 5.22.1, 5.2.0      |

### 👉 Des cellules 🙋

Chaque début de ligne identifie une cellule ojs. Chaque ligne définit une variable et une cellule qui doit être unique sur l'ensemble du document.

En début de cellule, on n'utilisera pas les déclarations de variables avec **let**, **const** ou **var**.

``` {{ojs}}
a = 10 // une cellule
b = 20 // une cellule
```

``` {{ojs}}
c = a + b // une cellule
```

A l'intérieur d'un bloc de code, on écrit du vanilla JavaScript.

``` {{ojs}}
d = { 
  let a = 10 
  let b = 30
  return a + b 
} // Une cellule
```

### 👉 Des promesses sont résolues ✅

Dons ojs, les promesses sont résolues d'une cellule à l'autre. Cela permet d'enlever de la complexité liée à la conception asynchrone du JavaCript. Ca va être très ptratique quand on charge un jeu de données par exemple. 

### 👉 L'ordre des cellules n'a pas d'importance 🤯

On peut donc écrire ça

``` {{ojs}}
result = val1 * val2
```

avant ça

``` {{ojs}}
val1 = 10
val2 = 20
```

Le lien entre les cellules se fait de façon topologique et non de haut en bas.

![](fig/topology.png)

### 👉 Tout est réactif 🔥

Dès lors qu'une cellule est modifiée, les cellules qui en dépendent sont modifiées également.

Pour modifier la valeur d'une cellule, on utilise des **`Inputs`** (des composants proposés par OJS pour explorer les données) avec le mot clé [**`viewof`**](https://observablehq.com/@observablehq/inputs)

```{ojs}
viewof x = Inputs.range([0, 255], {step: 1})
```

```{ojs}
viewof y = Inputs.text({value: 30})
```

```{ojs}
viewof z = Inputs.radio([10, 100, 1000], {value: 10})
```

```{ojs}
x * y * z
```

Ce système est pratique pour modifier des visualisations de données.

Ici, un exemple avec un simple cercle dessiné en svg.

```{ojs}
viewof color = Inputs.color({ label: "Couleur", value: "#4ab58c" })
viewof radius = Inputs.range([1, 50], { label: "Rayon", step: 1, value: 100 })
viewof position = Inputs.range([50, 950], { label: "Position", step: 1, value: 50 })
```

```{ojs}
html`<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">
  <circle cx=${position} cy="50" r=${radius} fill="${color}"/>
</svg>`
```

## L'écosystème spatial de l'ojs

L'écosystème spatial de JavaScript est moins étoffé que ce qu'on peut trouver en Python ou en R. Mais on trouve quand même des choses intéressantes qui permettent de faire de la géomatique directement dans le navigateur web. Voici quelques exemples.

**Les fonctionnalités spatiales de `d3.js`**

::: columns
::: {.column width="8%"}
![](fig/d3.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`d3-geo`**](https://github.com/d3/d3-geo) est le module spatial de D3. Il permet de gérer les projections cartographiques, les formes sphériques et la trigonométrie sphérique. Voir aussi [**`d3-geo-projection`**](https://github.com/d3/d3-geo-projection). [**`d3-delaunay`**](https://github.com/d3/d3-delaunay) est une bibliothèque rapide pour calculer le diagramme de Voronoï d'un ensemble de points bidimensionnels. Elle est basée sur Delaunator, une bibliothèque rapide pour calculer la triangulation de Delaunay en utilisant des algorithmes de balayage. Le diagramme de Voronoï est construit en reliant les circonférences des triangles adjacents dans la triangulation de Delaunay. [**`d3-geo-voronoi`**](https://github.com/Fil/d3-geo-voronoi) est une adaptation de d3-delaunay sur la sphère.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/topojson.svg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`TopoJSON`**](https://github.com/topojson/topojson) est une extension de GeoJSON. La librairie permet de réaliser des opérations SIG basées sur la topologie (agrégation, voisins, simplification, etc.)
:::
:::

**Les bibliothèques SIG**

::: columns
::: {.column width="8%"}
![](fig/turf.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`turf`**](https://turfjs.org/) est une bibliothèque JavaScript pour l'analyse spatiale (de type SIG). Elle comprend les opérations spatiales traditionnelles, des fonctions d'aide pour la création de données GeoJSON, ainsi que des outils de classification des données et de statistiques. L'avantage de turf est d'être modulaire. On ne charge que ce dont on a besoin.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/spljs.jpg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`spl.js`**](https://turfjs.org/) est une implémentation de SpatiaLite (et de ses amis : sqlite, geos, proj, rttopo) pour le navigateur.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/geotoolbox.svg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`geotoolbox`**](https://github.com/neocarto/geotoolbox) est un outil javascript pour les géographes basé sur d3geo, topojson et jsts. Il permet de traiter simplement les propriétés geojson et fournit plusieurs opérations SIG utiles pour la cartographie thématique.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/gdal.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`Gdals3.js`**](https://github.com/bugra9/gdal3.js) est un portage des applications Gdal (gdal_translate, ogr2ogr, gdal_rasterize, gdalwarp, gdaltransform) vers Webassembly. Il permet de convertir des données géospatiales matricielles et vectorielles dans divers formats et systèmes de coordonnées.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/proj4.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`proj4js`**](http://proj4js.org/) est une bibliothèque JavaScript permettant de transformer les coordonnées d'un système de coordonnées à un autre, y compris les transformations de datum
:::
:::

**Dataviz / cartographie**

::: columns
::: {.column width="8%"}
![](fig/plot.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`plot`**](https://observablehq.com/plot/) est la bibliothèque de visualisation de donnée développée par Observable (Mike Bostock et Philippe Rivière). Au départ pensée pour la visualisation de données statistiques, elle permet aujourd'hui de réaliser des cartes. Plot est disponible par défaut dans les cellules {ojs}.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/vega.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`vega-lite`**](https://github.com/vega/vega-lite) est un outil de visualisation mettant en œuvre une grammaire graphique, similaire à ggplot2. Cette bibliothèque est disponible par défaut dans les cellules {ojs}.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/bertin.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`bertin`**](https://github.com/neocarto/bertin) est une bibliothèque écrite en JavaScript qui permet de réaliser des cartes thématiques pour le web. Sa conception vise à permettre aux utilisateurs de créer rapidement des cartes thématiques interactives sans forcement connaître le langage JavaScript.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/gridviz.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`Gridviz`**](https://github.com/eurostat/gridviz) est une bibliothèque JavaScript basée sur WebGL développée par Julien Gaffuri et Joe Davies. Elle permet de visualiser des données carroyées (ou tout ensemble de données tabulaires avec une position x/y) dans le navigateur dans une grande variété de styles cartographiques.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/logo-go-cart-wasm.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`go-cart-wasm`**](https://github.com/riatelab/go-cart-wasm) est une bibliothèque JS/WASM permettant de réaliser des cartogrammes basés sur le flux (comme décrit dans "Gastner, Seguy, and More (2018).
:::
:::

## Importer des données

Pour importer des données en **`{ojs}`**, on utilise l'instruction **`FileAttachment()`**

Pour un fichier JSON

``` js
mrc = FileAttachment("data/mrc.geojson").json()
munic = FileAttachment("data/munic.geojson").json()
```

Pour un fichier csv

``` js
FileAttachment("data.csv").csv({typed: true})
```
On peut aussi récupérer des données depuis R ou Python avec l'instruction [**`ojs_define`**](https://neocarto.github.io/docs/notebooks/ojsdefine/)

::: {.callout-tip}
## NB
*Souvenez vous que le code JavaScript s'execute dans le navigateur web. Il s'execute donc après le code R et Python.*
:::

`ojs_define` fonctionne bien pour des simples variables ou des data frames. Mais ne renvoie pas un geoJSON correctement formaté à partir d'un spatial dataframe.

*chunck r*

```{r}
ojs_define(test = mun)
```

*Chuck ojs*

```{ojs}
test
```

Une solution consiste à utiliser le package `geojsonsf.`

*Chunck r*

```{r}
library("geojsonsf")
ojs_define(mun = sf_geojson(st_transform(mun, 4326)))
```

`mun` existe desormais dans l'univers ojs et est correctement formaté. Mais c'est une chaine de caractere. On utilisera donc `JSON.parse` pour l'utiliser

*Chunk ojs*

```{ojs}
JSON.parse(mun)
```

```{ojs}
//| eval: true
//| echo: false
tmp = FileAttachment("data/munic.geojson").json()
munic =  geo.rewind(geo.simplify(tmp, {k:0.1}))
tmp2 = FileAttachment("data/mrc.geojson").json()
mrc =  geo.rewind(geo.simplify(tmp2, {k:0.1}))

```

## Visualiser les données statistiques

Pour regarder la table attributaire, on utilise **`Inputs.table()`**

```{ojs}
Inputs.table(munic.features.map(d => d.properties))
```

Avec **`{ojs}`**, on va aussi pouvoir faire des graphiques avec la bibliothèque **`plot`**. Pour cela, on fait quelques manipulations de données.

Tout d'abord, on récupère les noms des 20 communes les plus peuplées, classées par ordre décroissant de population.

```{ojs}
communes = munic.features
  .map((d) => d.properties)
  .sort((a, b) => d3.descending(a.POP_2022, b.POP_2022))
  .map((d) => d.MUS_NM_MUN)
  .slice(0, 20)
```

```{ojs}
//| echo: false
//| eval: true
communes
```

On met en forme les données.

```{ojs}
data = {
  let arr = [];
  communes.forEach((d) => {
    let tmp = munic.features
      .map((d) => d.properties)
      .find((x) => x.MUS_NM_MUN == d);
    for (let i = 2001; i <= 2022; i++) {
      arr.push({ year: i, pop: tmp["POP_" + i], com: d });
    }
  });
  return arr;
}
```

```{ojs}
//| echo: false
//| eval: true
Inputs.table(data, {width:250, height:250})
```

Puis on réalise le graphique avec `Plot` en proposant de sélectionner une commune.

::: {.callout-tip}
## NB
*Plot est directement disponible dans {ojs}. Mais si on souhaite une autre version, on peut l'appeler.*
```{ojs}
Plot = require("@observablehq/plot@0.6.7")
```
*La version 0.6.7 implémente les infobulles.*
:::





```{ojs}
viewof commune = Inputs.select(communes, { label: "Commune" })
Plot.plot({
  grid: true,
  x: {
    label: "Années →",
    tickFormat: ""
  },
  y: {
    label: `↑ Population (${commune})`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data.filter(d => d.com == commune), {
      x: "year",
      y: "pop",
      stroke: "red",
      strokeWidth: 2
    })
  ]
})
```

On peut également mettre toutes les courbes sur un graphique

```{ojs}
Plot.plot({
  grid: true,
  x: {
    label: "Années →",
    tickFormat: ""
  },
  y: {
    label: `↑ Population`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data, {
      x: "year",
      y: "pop",
      stroke: "com",
      strokeWidth: 2,
      tip: true
    })
  ]
})
```

Ou en normalisant

```{ojs}
Plot.plot({
  grid: true,
  x: {
    label: "Années →",
    tickFormat: ""
  },
  y: {
    label: `↑ Population`
  },
  marginLeft: 60,
  marks: [
    Plot.lineY(data, Plot.normalizeY("first",{
      x: "year",
      y: "pop",
      stroke: "com",
      strokeWidth: 2,
      tip: true
    }))
  ]
})
```

## Visualiser les géométries

Comme leaflet [@Leaflet] est disponible dans les cellules {ojs}, on peut directement afficher les géométries.

```{ojs}
{
  const container = yield htl.html`<div style="height: 500px;">`;
  const map = L.map(container);
  const layer = L.geoJSON(mrc).addTo(map);
  map.fitBounds(layer.getBounds(), { maxZoom: 9 });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution:
      "© <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors"
  }).addTo(map);
}
```

On peut également afficher la carte simplement avec la bibliothèque [**`bertin`**](https://github.com/neocarto/bertin).

```{ojs}
bertin = require("bertin")
```

```{ojs}
bertin.quickdraw(mrc)
```

## Un peu de SIG

La bibiothèque **`geotoolbox`** permet de faire facilement differentes operations SIG.

```{ojs}
geo = require("geotoolbox")
```

-   **Simplification**

```{ojs}
viewof simpl = Inputs.range([0.0001, 0.2], { label: "Simplification",  value: 0.1 })
mrc2 = geo.simplify(mrc, { k: simpl })
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: munic},layers:[{geojson: mrc2, stroke:"black", strokeWidth:1.5, fill:"white", rewind: true}]})
```

-   **Centroid**

```{ojs}
ctr = geo.centroid(mrc)
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: mrc}, layers:[{geojson: ctr, fill:"red"},{geojson: mrc, fill:"#CCC"}, ]}) 
```

-   **Buffer**

```{ojs}
quebec = geo.filter(mrc, (d) => d.MUS_CO_MRC == "23")
buff = geo.buffer(quebec, { dist: distance})
ctr2 = geo.clip(ctr, {clip: buff})
```

```{ojs}
//| echo: false
viewof distance = Inputs.range([0, 500], {
  label: "Distance",
  value: 300,
  step: 10
})
bertin.draw({layers:[{geojson: quebec, fill:"red"}, {geojson: ctr2, fill:"red"}, {geojson: buff, stroke:"red", fill: "none", strokeWidth:2},{geojson: mrc, fill:"#CCC"}, ]}) 
```

## Cartographie thématique

Pour créer des cartes thématiques, on peut utiliser la bibliothèque [**`bertin`**](https://github.com/neocarto/bertin) [@bertinS].

La fonction **`draw`** permet de réaliser n'importe quel type de carte.

![](fig/bertin_code.png)

Par défaut, la couche s'affiche simplement.

```{ojs}
bertin.draw({layers:[{geojson: munic, fill: "#d18de0"}]})
```

On peut ajouter l'attrubut **`tooltip`** pour afficher des infobulles.

```{ojs}
bertin.draw({
  layers:[
    { 
      geojson: munic, fill: "#d18de0",
      tooltip: "$MUS_NM_MUN"
    }
  ]
})
```

**Cartographie thématique**

A présent, réalisons une carte de la population en 2022. Pour cela, on utilise le type **`bubble`**.

Par défaut, ça donne ceci :

```{ojs}
bertin.draw({
    layers: [
      {
        type: "bubble",
        geojson: munic, 
        values: "POP_2022", 
        fill:"red"
      },
      {
        geojson: munic,
        fill: "#CCC"
      }, 
  ]
})
```

Et en paramétrant un peu, on obtient ceci.

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", //  identifiant de la couche
      type: "bubble", // couche de symboles proportionnels
      geojson: munic, 
      values: "POP_2022", // variable à cartographier 
      k: 50, // Rayon du plus gros cercle
      leg_x: 740,
      leg_y: 350,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] // infobulle
    },
    {geojson: munic, fill:"#CCC"}, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut facilement combiner cette couche de cercles avec un une carte choroplèthe.

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "white",
      fillOpacity:0.2,
      stroke:"black",
      strokeWidth:1.4,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalité\néconomique",
            leg_round: 2
        }
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut aussi colorier les cercles

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalité\néconomique",
            leg_round: 2
        },
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: "#CCC"
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut utiliser les **`Inputs`** pour tester des visualisations, explorer les données ou proposer des interactions à un utilisatuer.

```{ojs}
// Inputs
viewof symbology = Inputs.radio(["bubble", "square", "spikes", "smooth", "dotdensity"], { label: "symbologie",   value: "bubble"})
viewof r = Inputs.range([10, 100], { label: "taille", step: 1, value: 50, disabled : ["bubble", "square", "spikes"].includes(symbology) ? false: true})
viewof toggle = Inputs.toggle({label: "dorling", value: false, disabled : ["bubble", "square", "dotdensity"].includes(symbology) ? false: true})
viewof thresholds = Inputs.range([5, 50], { label: "thresholds", step: 1, value: 23, disabled : symbology == "smooth" ? false : true})
viewof bandwidth = Inputs.range([5, 50], { label: "bandwidth", step: 1, value: 27, disabled : symbology == "smooth" ? false : true })
viewof filterpop = Inputs.range([1000, 100000], { label: "POP >= ", step: 1, value: 1000})
// Carte
bertin.draw({
    params: { extent: [[-79, 44.5], [-66, 51]]},
    layers: [
      {
        type: symbology,
        geojson: geo.filter(munic, (d) => d.POP_2022 >= filterpop), 
        values: "POP_2022", 
        fill: symbology == "smooth" ? "RdYlGn" : "red",
        fillOpacity:0.7,
        dorling: toggle,
        k: r,
        thresholds,
        bandwidth,
        symbol_size:25,
        w:15,
        symbol_shift : toggle ? 1 : 0,
        stroke : symbology == "spikes" ? "red" : "white",
        tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
      },
      {
        geojson: munic,
        fill: "#CCC",
        stroke : toggle ? "#CCC" : "white"
      }, 
  ]
})
```

## Références

<ins>Documentation</ins>

-   [github.com/neocarto/bertin](https://github.com/neocarto/bertin)

<ins>Exemples</ins>

-   [observablehq.com/\@neocartocnrs/bertin-js-tooltips?collection=\@neocartocnrs/bertin](https://observablehq.com/@neocartocnrs/bertin-js-tooltips?collection=@neocartocnrs/bertin)
-   Lambert N. (2023) Observable en bref. Webinaire 'Interroger les données', Groupe de travail 'Atelier Données' du CNRS. [observablehq.com/\@neocartocnrs/webinaire-interroger-les-donnees](https://observablehq.com/@neocartocnrs/webinaire-interroger-les-donnees)
-   Lambert N. (2023) Cartographie thématique avec ojs. École d'été internationale, Ouidah. [https://ee-cist.github.io/CAR2_cartodyn/intro/docs/index.html](ee-cist.github.io/CAR2_cartodyn/intro/docs/index.html%5D)

## À vous de jouer

::: {.callout-caution appearance="simple"}
## faire des cartes avec {ojs}

::: {.callout-note icon="false"}
## Objectif

Réaliser comme ci-dessous, une carte [choroplèthe](http://geoconfluences.ens-lyon.fr/glossaire/choroplethe-choroisoplethe) sur une région du Québec que l'on peut selectionner dans une liste déroulante.

```{ojs}
//| echo: false
//| eval: true
viewof myregion =  Inputs.select(["Estrie","Capitale-Nationale","Bas-Saint-Laurent"], {label: "Choisissez une région"})
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
bertin.draw({ layers: [{type:"header", text: `Les actifs (${myregion})`},{type:"scalebar"},{ geojson: myreg, rewind: true, fill: {type:"choro", values: "TX_2564", colors: "RdYlGn", leg_x: 2, leg_y:2, leg_title:"Taux d'actifs", leg_round:1}, tooltip:["$MUS_NM_MUN", d => "Taux d'actifs :" + d.properties.TX_2564 + "%"]}] })
```
:::

**A vous de jouer**

-   Chargez la bibliothèque [`bertin`](https://github.com/neocarto/bertin)
-   Importez la couche `munic.geojson`

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Pour importer des données au format JSON en Observable JavaScript, on utilise l'instruction `FileAttachment()`
:::

-   Afficher le fond de carte avec la fonction [`draw`](https://github.com/neocarto/bertin#drawing-a-map)

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

La fonction draw prend en entrée un objet qui a la structure suivante :

``` js
bertin.draw({
  layers: [{...}]
})
```
:::

::: {.callout-tip icon="false" collapse="true"}
## Astuce

Si la carte ne s'affiche pas correctement, utiliser l'attribut `rewind:true`
:::

-   Afficher les données attributaires.

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

On peut afficher les données avec l'instruction. `Inputs.table()` Mais auparavant, il faut récupérer les propriétés du geoJSON comme ceci :

``` js
munic.features.map((d) => d.properties)
```
:::

-   Créer une liste déroulante pour choisir parmi 3 régions à étudier

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Par exemple :

``` js
mesregions = ["Estrie","Capitale-Nationale","Bas-Saint-Laurent"]
viewof myregion =  Inputs.select(mesregions, {label: "Choisissez une région"})
```
:::

-   Créez un nouveau fond de carte contenant uniquement les municipalités de la région définie par la liste déroulante.

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Pour créer ce sous jeu de données, on peut utiliser la fonction `subset` de la bibliothèque `bertin`.

``` js
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
```
:::

-   Afficher le nouveau fond de carte
-   Définisser la couleur de fond, l'épaisseur des traits, la couleur des contours.
-   Réaliser une carte [chorplèthe](https://github.com/neocarto/bertin#choropleth) à partir d'une variable disponible. Par exemple, le taux d'actifs (TX_2564).

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Définissez l'attribut `fill` par un objet commençant par `{type: choro, values: ...}`
:::

-   Changez les couleurs et la méthode de discretisation

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

La documentation est disponible [ici](https://github.com/neocarto/bertin#choropleth)
:::

-   Ajouter un [titre](https://github.com/neocarto/bertin#header)
-   Ajouter la légende
-   Ajouter l'[échelle](https://github.com/neocarto/bertin#scalebar)
-   Ajoutez des [infobulles](https://observablehq.com/@neocartocnrs/bertin-js-tooltips)

::: {.callout-caution collapse="true"}
## SOLUTION

```{ojs}
//| echo: true
//| eval: false
bertin = require("bertin")
munic = FileAttachment("munic.geojson").json()
viewof myregion = Inputs.select(
  ["Estrie", "Capitale-Nationale", "Bas-Saint-Laurent"],
  { label: "Choisissez une région" }
)
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
bertin.draw({
  layers: [
    { type: "header", text: `Les actifs (${myregion})` },
    { type: "scalebar" },
    {
      geojson: myreg,
      rewind: true,
      fill: {
        type: "choro",
        values: "TX_2564",
        colors: "RdYlGn",
        leg_x: 2,
        leg_y: 2,
        leg_title: "Taux d'actifs",
        leg_round: 1
      },
      tooltip: [
        "$MUS_NM_MUN",
        (d) => "Taux d'actifs :" + d.properties.TX_2564 + "%"
      ]
    }
  ]
})
```
:::
:::

<!-- ## Le petit plus : dépôt et déploiement continu avec GitHub. -->

