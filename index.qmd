---
title: "Articulation de diff√©rents langages (R, JavaScript et Python) pour la g√©ovisualisation avec Quarto"
subtitle: "Atelier Sageo, Qu√©bec, Juin 2023"
author: 
  - name: "Timoth√©e Giraud, Nicolas Lambert, Matthieu Viry, Ronan Ysebaert"
    affiliations:
      - id: 1
        name: RIATE (CNRS, Universit√© Paris Cit√©)
        url: https://riate.cnrs.fr
format:
  html:
    theme: sandstone
    fontsize: 0.9em
    code-tools: true
    toc: true
    toc-depth: 2
    linkcolor: "#8631ad"
execute: 
  cache: false
editor_options: 
  chunk_output_type: console
bibliography: references.bib
csl: "universite-de-montreal-apa.csl"
lang: fr
---

![](fig/SAGEO.png)

## Pr√©sentation

Dans un contexte d‚Äôessor de carnets interactifs (Notebooks), l‚Äôobjet de cet atelier consiste √† montrer les possibilit√©s offertes par Quarto, un syst√®me de publication scientifique et technique open-source bas√© sur Pandoc, qui permet d‚Äôarticuler diff√©rents langages pour r√©aliser des g√©ovisualisations reproductibles dans un seul et m√™me document. Cet atelier proposera aux participants une prise en main des principales fonctionnalit√©s offertes par Quarto, puis une mise en ≈ìuvre de cha√Ænes de traitements de l‚Äôinformation g√©ographique reproductibles avec R, Python et Observable JavaScript dans cet environnement.

### D√©roul√© de la demi-journ√©e

-   Installation des logiciels n√©cessaires √† la mise en - place de l'environnement de d√©veloppement (Quarto, R, Python, RStudio, Jupyter...). / **A envoyer aux participants en d√©but de semaine ?**
-   Pr√©sentation et prise en main des principales fonctionnalit√©s des notebooks Quarto. Pr√©sentation des √©cosyst√®mes spatiaux de R et Python, et, d'un jeu de donn√©es commun sur - lequel s'appuiera l'ensemble de l'atelier.
-   Traitement des donn√©es vectorielles : Mise en pratique d'une cha√Æne de traitements reproductible avec R, notamment gr√¢ce aux packages sf et mapsf.
-   Traitement des donn√©es raster : Mise en pratique d'une cha√Æne de traitements reproductible avec Python (biblioth√®ques geopandas, rasterio, matplotlib, nbdev, etc.).
-   Cr√©ation de visualisations cartographiques interactives avec ojs (biblioth√®ques bertin, Plot, Gridviz, Deck.gl).
-   Export/publication du document quarto produit pendant l'atelier (templates de diff√©rentes revues scientifiques, slides, https://quartopub.com/, etc.).


## Donn√©es atelier

Plusieurs possibilit√©s si espace d'√©tude canadien : 

**Vecteur**

-   [OpenStreetMap](https://www.openstreetmap.org/) (POI) : restos, bars. 
-   Le d√©coupage g√©ographique des municipalit√©s qu√©b√©coises (Source : [Minist√®re des Ressources naturelles et des For√™ts](https://mrnf.gouv.qc.ca/repertoire-geographique/carte-generale-base-donnees-geographiques-administratives/)).
-   La s√©rie de population 2001-2022 et l'indice de vitalit√© √©conomique des localit√©s qu√©becoises, d√©livr√© par l'[Institut de la Statistique du Qu√©bec](https://statistique.quebec.ca/fr/recherche?territoire=municipalites&type_produit=tableau-detaille).

**Raster** 

- Estimations de population d√©sagr√©g√©es : [World Pop Canada 100 m res - 42 Mo](https://hub.worldpop.org/geodata/summary?id=49922) + [USA - 417 MB](https://hub.worldpop.org/geodata/summary?id=49916) ou [1km - CAN](https://hub.worldpop.org/geodata/summary?id=34942) / [USA - 49.42 MB](https://hub.worldpop.org/geodata/summary?id=34816)
- Couverutre du sol : ESA World Cover ? source [European Space Agency](https://worldcover2020.esa.int/download) ou [NASA](https://ladsweb.modaps.eosdis.nasa.gov/missions-and-measurements/science-domain/land-cover-and-phenology/) + [Guide](https://lpdaac.usgs.gov/documents/101/MCD12_User_Guide_V6.pdf). Sur le Qu√©bec cf [Comptes des terres du Qu√©bec M√©ridional](https://statistique.quebec.ca/cartovista/comptes_terres/index.html) et [GeoTIFF associ√©](https://www.donneesquebec.ca/recherche/fr/dataset/comptes-des-terres-du-quebec-meridional-changement-de-la-couverture-terrestre) 
-  Intensit√© pollution lumineuse : [Earth Observation Group](https://eogdata.mines.edu/products/vnl/)



::: {.callout-caution collapse="true"}
### \[To do\] : T√©l√©charger les donn√©es de l'exercice

T√©l√©charger les donn√©es utiles √† reproduire l'exercice (d√©p√¥t github √† part) - Les donn√©es - Les scripts R, Python et Ojs.

Ouvrir le fichier projet.
:::

## Pr√©paration des donn√©es

Dans cet atelier nous allons utiliser des donn√©es portant sur les municipalit√©s du Qu√©bec. Dans un premier temps nous avons pr√©par√© et nettoy√© les donn√©es avec le logiciel R. 
Les diff√©rentes √©tapes de pr√©paration sont d√©crites dans le script suivant.  

```{r}
#| eval: false
#| code-fold: true
library(sf)
library(mapsf)
library(readxl)
library(rmapshaper)

# Communes
mun <- st_read("geom/munic_s.shp", quiet = TRUE)
# Transformation conique √©quivalente d'ALbers
mun <- st_transform(mun, 6623)
# Suppression des surfaces en eau
mun <- mun[!is.na(mun$MUS_CO_GEO),]
# Selection des variables pertinentes
mun <- mun[, c("MUS_CO_GEO", "MUS_NM_MUN", "MUS_CO_MRC", "MUS_NM_MRC", "MUS_NM_REG")]
# Simplifier les contours des polygones
mun <- ms_simplify(mun, )

# Agregation des multipolygones
mun <- aggregate(x = mun[, -1], 
                 by = list(MUS_CO_GEO = mun$MUS_CO_GEO),
                 FUN = head, 1)
mun <- st_cast(mun, "MULTIPOLYGON")

# Import donn√©es population et nettoyage
df <- read_xlsx("data/stats_socio_eco/Pop-MUN-total.xlsx", 
                skip = 3, n_max = 1292,
                col_types = c(rep("text", 2),"numeric",rep("text", 4), 
                              rep("numeric", 22))) 
df <- as.data.frame(df)
df <- df[,c(1:3, 8:29)]
col_pop <- paste0("POP_", seq(2001, 2022, 1))
colnames(df) <- c("NOM", "STATUT", "MUS_CO_GEO", col_pop)
df$MUS_CO_GEO <- formatC(df$MUS_CO_GEO, width = 5, flag = "0", format = "d")

mun <- merge(mun, df, by = "MUS_CO_GEO", all.x = T)


# Import donn√©es socio-√©co et nettoyage
df2 <- data.frame(read_xlsx("data/stats_socio_eco/Tableau.xlsx", 
                            skip = 4, n_max = 1163))
df2 <- df2[-c(1:2),]
df2 <- df2[,c(2:4,6,8,10)]
colnames(df2) <- c("NOM", "REG", "VIT_ECO", "REV_MED", "TX_2564", "TAAM")
df2$id <- paste0(df2$NOM, "_", df2$REG)

df2$VIT_ECO <- as.numeric(df2$VIT_ECO)
df2$REV_MED <- as.numeric(df2$REV_MED)
df2$TX_2564 <- as.numeric(df2$TX_2564)
df2$TAAM <- as.numeric(df2$TAAM)
mun$id <- paste0(mun$NOM, " (", mun$STATUT, ")_", mun$MUS_NM_REG)
mun <- merge(mun, df2, by = "id", all.x = TRUE)
mun <- mun[, c(2:6, 8:30, 33:36)]



# agregation de municipalit√© en Municipalit√© r√©gionale de comt√© (MRC)
mun <- st_set_precision(mun, 1)
mrc <- aggregate(mun[, c("MUS_NM_MRC","MUS_NM_REG")], 
                 by = list(MUS_CO_MRC = mun$MUS_CO_MRC),
                 FUN = head, 1)
mrc <- st_cast(mrc, "MULTIPOLYGON")
mun <- st_set_precision(mun, 0)

st_write(st_transform(mrc, 4326), "geom/mrc.geojson")
st_write(st_transform(mun, 4326), "geom/munic.geojson")
```

Ce script abouti √† la cr√©ation de deux fichiers. 
mrc.geojson est un fond de carte des Municipalit√© R C. 
munic.geojson et un fond de carte des municipalit√©s contenant des donn√©es socio-d√©mographiques. 


# R

## L'√©cosyst√®me spatial de R

Le logiciel R [@R-base] permet depuis longtemps de traiter et repr√©senter les donn√©es spatiales.\
Le principal package permettant de traiter les donn√©es vectorielles avec R est le package `sf` [@R-sf].\
Les packages `stars` [@pebesma2023] et `terra` [@R-terra] quand √† eux sont les principaux packages d√©di√©s au traitement des donn√©es raster.

Les d√©veloppements actuels s'appuient sur ce socle et forment un √©cosyst√®me robuste qui offre aux utilisateurs la plupart des fonctionnalit√©s autrefois r√©serv√©es aux Syst√®mes d'Information G√©ographique.\
Le package `mapsf` [@R-mapsf] par exemple s'appuie sur le package `sf` pour cr√©er des cartes th√©matiques. D'autres packages sont d√©di√©s √† la cartographie interactive, aux statistiques spatiales, l'interaction avec des API de cartographie, la cr√©ation de cartogrammes etc.

## Le package `sf`

<img src="fig/logo_sf.gif" align="right" width="150"/>

Le package `sf` a √©t√© publi√© fin 2016 par Edzer Pebesma. Ce package permet l'import, l'export, la manipulation et l'affichage de donn√©es spatiales vectorielles. Pour cela `sf` s'appuie sur une s√©rie de biblioth√®ques spatiales : GDAL [@GDAL] et PROJ [@PROJ] pour les op√©rations d'import, d'export et de projection, et GEOS [@GEOS] pour les op√©rations de g√©otraitement (buffer, intersection...).\
Ce package propose des objets simples (suivant le standard [*simple feature*](https://en.wikipedia.org/wiki/Simple_Features)) dont la manipulation est assez ais√©e. Une attention particuli√®re a √©t√© port√©e √† la compatibilit√© du package avec la syntaxe *pipe* (`|>` ou `%>%`) et les op√©rateurs du `tidyverse` [@R-tidyverse].

![@pebesma2023](fig/sf_deps.png)

::: callout-note
## Historique

Le package `sf` est venu remplacer les packages `sp` [@R-sp], `rgeos` [@R-rgeos] et `rgdal` [@R-rgdal] en combinant leurs fonctionnalit√©s dans un package unique plus ergonomique.
:::

::: panel-tabset
```{r knit_init}
#| include: false
#| cache: false
knitr::knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  } 
})
knitr::opts_chunk$set(nm=TRUE, echo=TRUE)
```

### Format

![Format des objets spatiaux `sf`](fig/sf.png)

Les objets `sf` sont des `data.frame` dont l'une des colonnes contient des g√©om√©tries.\
Ce format est tr√®s pratique dans la mesure ou les donn√©es et les g√©om√©tries sont intrins√®quement li√©es dans un m√™me objet.

::: callout-note
## Vignette d√©crivant le format simple feature

[Simple Features for R](https://r-spatial.github.io/sf/articles/sf1.html)
:::

### Import

```{r sf_import_fake}
#| eval: false
library(sf)
mtq <- st_read(dsn = "data/mtq.gpkg",layer = "mtq")
```

```{r sf_import}
#| include: false
library(sf)
library(mapsf)
mtq <- mf_get_mtq()
```

### Affichage

```{r sf_plot, fig.height=3, fig.width=3, nm=TRUE}
plot(st_geometry(mtq))
```

```{r sf_plot_multi, fig.height=4, fig.width=7, nm=TRUE}
plot(mtq)
```

### Centroides

```{r sf_centro,  fig.height=3, fig.width=3, nm=TRUE}
mtq_c <- st_centroid(mtq)
plot(st_geometry(mtq))
plot(st_geometry(mtq_c), cex = 1.2, col = "red", pch = 20, add = TRUE)
```

### Matrice de distance

```{r sf_matrix,  fig.height=3, fig.width=3, nm=TRUE}
mat <- st_distance(x = mtq_c, y = mtq_c)
mat[1:5, 1:5]
```

### Ag√©regation

```{r sf_agg,  fig.height=3, fig.width=3, nm=TRUE}
mtq_u <- st_union(mtq)
plot(st_geometry(mtq), col = "lightblue")
plot(st_geometry(mtq_u), lwd = 2, border = "red", add = TRUE)
```

### Zone tampon

```{r sf_buff,  fig.height=3, fig.width=3, nm=TRUE}
mtq_b <- st_buffer(x = mtq_u, dist = 5000)
plot(st_geometry(mtq_b), col = "grey", lwd = 2, border = "red")
plot(st_geometry(mtq), col = "lightblue", add = TRUE)
plot(st_geometry(mtq_u), lwd = 2, add = TRUE)
```

### Intersection

```{r sf_interse,  fig.height=3, fig.width=3, nm=TRUE, echo=FALSE}
m <- rbind(c(700015,1624212), c(700015,1641586), 
           c(719127,1641586), c(719127,1624212), 
           c(700015,1624212))
p <- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq))
plot(st_geometry(mtq))
plot(p, border="red", lwd=2, add=T)
text(719127,1641586, "p", pos = 4, cex = 3)
```

```{r sf_intersect2,  fig.height=3, fig.width=3, nm=TRUE, warning=F}
#| layout-ncol: 2
mtq_z <- st_intersection(x = mtq, y = p)
plot(st_geometry(mtq))
plot(st_geometry(mtq_z), col = "red", border = "green", add = TRUE)
plot(st_geometry(mtq_z), lwd = 2)
```

### Polygones de Voronoi

```{r sf_voronoi,  fig.height=3, fig.width=3, nm=TRUE}
mtq_c |> 
  st_union() |> 
  st_voronoi() |> 
  st_collection_extract("POLYGON") |> 
  st_intersection(mtq_u) |> 
  st_sf() |> 
  st_join(mtq_c, st_intersects) |>
  st_cast("MULTIPOLYGON") |>
  st_geometry() |>
  plot(col = "ivory4")
```
:::

## Le package `mapsf`

<img src="fig/logo_mapsf.png" align="right" width="150px"/>

`mapsf` permet de cr√©er la plupart des types de carte utilis√©s habituellement en cartographie statistique.\
Pour chaque type de carte, plusieurs param√®tres permettent de personnaliser la repr√©sentation cartographique. Ces param√®tres sont les m√™mes que ceux que l'on retrouve dans les logiciels de SIG ou de cartographie usuels.\
Associ√©es aux fonctions de repr√©sentation des donn√©es d'autres fonctions sont d√©di√©es √† l'habillage cartographique, √† la cr√©ation de cartons ou √† l'export des cartes.\
`mapsf` est le successeur de [`cartography`](http://riatelab.github.io/cartography/docs/) [@R-cartography], il offre les m√™mes fonctionnalit√©s principales tout en √©tant plus l√©ger et plus ergonomique.

![Cha√Æne de traitement typique](fig/workflow.png)

::: panel-tabset
### Types de carte

::: {layout="[[1,1,1], [1,1,1]]"}
![](fig/map01.png)

![](fig/map02.png)

![](fig/map03.png)

![](fig/map04.png)

![](fig/map05.png)

![](fig/map06.png)

![](fig/map07.png)

![](fig/map08.png)

![](fig/map09.png)
:::

### Utilisation simple

```{r mapsf_simple}
#| fig-width: 5
#| fig.height: 6
library(mapsf)
# Import the sample dataset
mtq <- mf_get_mtq()
# Plot the base map
mf_map(x = mtq)
# Plot proportional symbols
mf_map(x = mtq, var = "POP", type = "prop")
# Plot a map layout
mf_layout(title = "Population in Martinique", 
          credits = "T. Giraud; Sources: INSEE & IGN, 2018")
```

### Utilisation avanc√©e

```{r mapsf_avance}
#| results: hide
# Export a map with a theme and extra margins 
mf_export(x = mtq, filename = "fig/mtq.svg",  width = 5, 
          theme = "green", expandBB = c(0,0,0,.3)) 
# Plot a shadow
mf_shadow(mtq, col = "grey10", add = TRUE)
# Plot a choropleth map
mf_map(x = mtq, var = "MED", type = "choro",
       pal = "Dark Mint", 
       breaks = "quantile", 
       nbreaks = 6, 
       leg_title = "Median Income\n(euros)", 
       leg_val_rnd = -2, 
       add = TRUE)
# Start an inset map
mf_inset_on(x = "worldmap", pos = "right")
# Plot mtq position on a worldmap
mf_worldmap(mtq, col = "#0E3F5C")
# Close the inset
mf_inset_off()
# Plot a title
mf_title("Wealth in Martinique, 2015")
# Plot credits
mf_credits("T. Giraud\nSources: INSEE & IGN, 2018")
# Plot a scale bar
mf_scale(size = 5)
# Plot a north arrow
mf_arrow('topleft')
dev.off()
```

![](fig/mtq.svg){width="500px"}

```{r reset_theme}
#| include: false
mf_theme("default")
```
:::

::: callout-note
D'autres packages peuvent √™tre utilis√©s pour r√©aliser des cartes th√©matiques.\
Le package `ggplot2` [@R-ggplot2], en association avec le package `ggspatial` [@R-ggspatial], permet par exemple d'afficher des objets spatiaux et de r√©aliser des cartes th√©matiques simples.\
Le package `tmap` [@R-tmap] est d√©di√© √† la cr√©ation de cartes th√©matiques, il utilise une syntaxe proche de celle de `ggplot2` (encha√Ænement d'instructions combin√©es avec le signe `+`).\
La documentation et les tutoriels pour utiliser ces deux packages sont facilement accessibles sur le web.
:::

## Ressources

[Geocomputation with R](https://r.geocompx.org/) - @lovelace2019

[Spatial Data Science with applications in R](https://r-spatial.org/book/) - @pebesma2023

[Spatial Data Science with R and "terra"](https://rspatial.org/) - Robert J. Hijmans

[Progress in the R ecosystem for representing and handling spatial data](https://link.springer.com/article/10.1007/s10109-020-00336-0) - @bivand2021

[Cartographie avec R](https://rcarto.github.io/cartographie_avec_r/) - @Giraud_Cartographie_avec_R_2023

[G√©omatique avec R](https://rcarto.github.io/geomatique_avec_r/) - @Giraud_Geomatique_avec_R_2023

[CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html)

[R Special Interest Group on using Geographical data and Mapping](https://stat.ethz.ch/mailman/listinfo/r-sig-geo) (mailing list)

## Exemples d'analyse sur les donn√©es du Qu√©bec

### Import et pr√©paration des donn√©es

Nous utilisons le package `sf` pour importer 2 fichiers geojson.\
Il est ensuite possible de changer la projection des couches avec la fonction `st_transform()`.\
Nous pouvons aussi cr√©er une couche des r√©gions du Qu√©bec en agr√©geant les Municipalit√© R√©gionales de Comt√©.

```{r import}
#| message: false
# Import des donn√©es
library(sf)
mun_raw <- st_read("geom/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("geom/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
mun <- st_transform(mun_raw, "EPSG:6623")
mrc <- st_transform(mrc_raw, "EPSG:6623")
# Cr√©ation d'une couche des r√©gions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
```

### Premi√®re cartographie simple

Sur cette premi√®re carte nous allons simplement afficher les diff√©rentes couches en les superposant.\
Nous utilisons le package `mapsf` qui permet aussi de cr√©er une couche d'√©tiquettes avec la fonction `mf_label()`.

```{r carto_quebec_reg}
#| fig-width: 8
#| fig-height: 10.05
library(mapsf)
mf_map(mun, border = "white")
mf_map(mrc, col = NA, border = "grey70", lwd = 1, add = TRUE)
mf_map(reg, col = NA, border = "black", lwd = 1.2, add = TRUE)
mf_label(reg, var = "MUS_NM_REG", halo = TRUE, overlap = FALSE)
mf_scale(size = 100)
mf_title("Le Qu√©bec")
mf_credits(txt = "Minist√®re des Ressources naturelles et des For√™ts, 2023", 
           bg = "#ffffffCC")
```

### O√π sont les restaurants dans la ville de Qu√©bec?

Nous voulons savoir dans quelles zones de la ville de Qu√©bec se trouvent les restaurants.\
Pour conna√Ætre la position des restaurants dans la ville nous allons extraire des informations la base de donn√©s cartographique libre OpenStreetMap avec le package `osmdata` [@R-osmdata]. Le package `osmdata` utilise l'API du service [Overpass turbo](https://overpass-turbo.eu/) pour extraire des donn√©es vectorielles de la base de donn√©es OpenStreetMap.

Nous devons tout d'abord d√©finir une emprise spatiale √† partir de laquelle nous pourrons extraire les informations sur les restaurants.\
Apr√®s avoir d√©marr√© les packages n√©cessaires, nous allons tout d'abord s√©lectionner la MRC de Qu√©bec dans la couche des MRC.

```{r target_city}
#| message: false
library(sf)
library(osmdata)
target <- mrc[mrc$MUS_NM_MRC == "Qu√©bec", ]
```

Nous allons ensuite d√©finir une *bounding box* correspondant √† l'emprise de la MRC. Le package `osmdata` fonctionne avec des objets en WGS84 nous avons donc besoin de reprojeter les donn√©es.

```{r create_bb}
# Reprojection en WGS84
target_4326 <- st_transform(target, "EPSG:4326")
# Cr√©ation de la bounding box
bbox <- st_bbox(target_4326)
```

Nous pouvons maintenant d√©finir ce que nous voulons extraire de la base de donn√©e OSM. Une connaissance de la structuration de la base de donn√©es OSM est n√©cessaire. Nous utilisons le syst√®me de clef/valeur pour construire la requ√™te.

```{r define_request}
# Initialisation de la requ√™te √† envoyer
q <- opq(bbox = st_bbox(bbox))
# Choix des objets √† extraire
req <- add_osm_feature(opq = q, 
                       key = 'amenity', 
                       value = "restaurant")


```

La fonction `osmdata_sf()` permet d'envoyer la requ√™te et de recevoir les r√©sultats sous forme de `data.frame` `sf`.

```{r send_request}
#| cache: true
# Reception de la requete
res <- osmdata_sf(q = req)
res
```

Ce r√©sultat contient des restaurants repr√©sent√©s par de points (*osm_points*) et d'autre repr√©sent√©s par des polygones (*osm_polygons*). La couche des points contient √©galement les points qui composent les polygones de la couche de polygones. La fonction `unique_osmdata()` permet de filtrer ces "doublons".

```{r filter_osm}
# Reduction du resultats 
# (les points composant les polygones sont supprim√©s)
res <- unique_osmdata(res)
res
```

L'√©tape suivante consiste √† utiliser extraire les points et les polygones, puis √† extraire les centroides des polygones pour constituer une couche de points compl√®te.

```{r build_layer}
#| warning: false
# Extraction des points
resto_point <- res$osm_points
# Extraction des polygones
resto_poly <- res$osm_polygons
# Transformation des polygones en points (centroides)
resto_poly_point <- st_centroid(resto_poly)
# Listes des champs √† conserver
chps <- c("osm_id", "name", "cuisine")
# Rassembler les 2 couches de points
resto <- rbind(resto_point[, chps], resto_poly_point[, chps])
resto
```

Maintenant que nous avons cette couche de restaurants nous allons pouvoir l'afficher.\
Pour cela nous pouvons utiliser un fond de carte issues de tuiles raster gr√¢ce au package `maptiles` [@R-maptiles]. Nous allons d'abord reprojeter les diff√©rentes couches d'information en Web/Mercator (EPSG:3857) car les tuiles raster sont fournies dans cette projection .

```{r reproj_layers}
target <- st_transform(target, "EPSG:3857")
resto <- st_transform(resto, "EPSG:3857")
```

Nous pouvons maintenant t√©l√©charger les tuiles raster grace √† la fonction `get_tiles()`.

```{r get_tiles}
library(maptiles)
tiles <- get_tiles(x = target, 
                   provider = "CartoDB.PositronNoLabels",
                   project = FALSE, 
                   crop = TRUE, 
                   zoom = 11)
```

Nous cr√©ons ensuite la carte avec `mapsf`.

```{r resto_map1}
#| results: hide
library(mapsf)
mf_theme(mar = c(0,0,0,0), inner = TRUE)
mf_export(x = tiles,
          filename = "fig/restaurants01.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, col = NA, lwd = 2, add = TRUE)
mf_map(resto, col = "red", add = TRUE)
mf_title("Les restaurants √† Qu√©bec")
mf_credits("¬© OpenStreetMap contributors ¬© CARTO", bg = "white")
dev.off()
```

![](fig/restaurants01.png)

Nous allons maintenant agr√©ger les restaurants dans une grille r√©guli√®re pour tenter rendre plus lisible l'organisation spatiale des restaurant √† Qu√©bec.

```{r grid}
#| results: hide
# Cr√©ation d'une grille r√©guli√®re (carreaux : 2km * 2km)
grid <- st_make_grid(target, cellsize = 2000)
grid <- st_sf(id = 1:length(grid), geom = grid)

# Comptage des points dans les polygones
grid$n <- lengths(st_intersects(grid, resto, sparse = TRUE))

# Cartographie
mf_export(x = tiles,
          filename = "fig/restaurants02.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, add = T, col = NA, lwd = 2)
mf_map(x = grid[grid$n >0 , ], 
       var = "n", 
       type = "choro", 
       breaks = 'geom', 
       nbreak = 6, 
       alpha= .75, 
       border = NA, 
       pal = "Burg", 
       leg_frame = TRUE, 
       leg_pos = "left", 
       leg_title = "Nombre de restaurants",
       leg_val_rnd = 0,
       add = TRUE)
mf_title("Les restaurants √† Qu√©bec")
mf_credits("¬© OpenStreetMap contributors ¬© CARTO", bg = "white")
dev.off()
```

![](fig/restaurants02.png)

Nous pouvons aussi utiliser une m√©thode de lissage telle que la m√©thode de lissage par noyaux (KDE) gr√¢ce au package `spatstat` [@R-spatstat].

```{r kde}
#| results: hide
#| message: false
#| warning: false
library(spatstat)
library(terra)
library(tanaka)
p <- as.ppp(st_coordinates(resto), W = as.owin(st_bbox(target)))
ds <- density.ppp(p, sigma = 500, 
                  eps = c(100, 100), positive = TRUE)
rasdens <- rast(ds) * 1000 * 1000
crs(rasdens) <- 'EPSG:3857'
mf_export(x = tiles,
          filename = "fig/restaurants03.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, add = T, col = NA, lwd = 2)
cols <- mf_get_pal(n = 5, palette = "Teal", rev = TRUE)
x <- tanaka_contour(rasdens, breaks = c(1,2,5,10,20,25))
tanaka(x[-1, ], legend.title = "Nombre de\nrestaurants\nau km¬≤",
       legend.pos = "topright", shift = 65,
       col = cols,
       add = TRUE)
mf_title("Les restaurants √† Qu√©bec")
mf_credits("¬© OpenStreetMap contributors ¬© CARTO",bg = "white")
dev.off()
```

![](fig/restaurants03.png)

# Python


# Observable JavaScript

## Qu'est-ce que l'ojs ?

L'<b>Observable javascript {ojs}</b> est un ensemble d'am√©liorations apport√©es √† vanilla JavaScript cr√©√© par Mike Bostock (√©galement auteur de D3). Observable JS se distingue par son ex√©cution r√©active, qui convient particuli√®rement bien √† l'exploration et √† l'analyse interactives des donn√©es.

![](fig/d3.png){width="20%"} ![](fig/arrow.png){width="20%"} ![](fig/observable.png){width="20%"} <br/> **Observable** est aussi une startup fond√©e par Mike Bostock et Melody Meckfessel, qui propose une plateforme 100% en ligne (<https://observablehq.com>) pour concevoir, partager et diffuser des visualisations de donn√©es.

![](fig/frise.png)

**Observable** c'est donc aussi C'est aussi une [plateforme web](https://observablehq.com/) qui h√©berge des notebooks computationnels sur la visualisation de donn√©es.

![](fig/notebookobs.png)

**Objectifs**

üëâ Construire un langage et un √©cosyst√®me d√©di√© √† la visualisation de donn√©es sur le web

üëâ F√©d√©rer et faire collaborer une communaut√©

## Observable dans Quarto

Le runtime d'Observable est Open Source et est utilis√© dans Quarto.

Dans Quarto, toutes les instructions s'√©crivent dans des chunks {ojs}

``` {{ojs}}
```

On peut param√©trer l'affiche et/ou l'execution du code avec **//\| echo** et **//\| eval**.

``` {{ojs}}
//| echo: false
//| eval: true
```

*NB : Contrairement aux chunks R et Python, le code s'execute just in time dans le navigateur web une fois le notebook g√©n√©r√©. Seul l'export html est donc pris en compte.*

## Principes

Le langage JavaScript n'a pas du √©t√© con√ßu pour l'analyse de donn√©es. Mais, gros point fort, on a tous un navigateur web et JavaScript tourne sur toutes les machines. Le but : b√¢tir une √©volution du langage JavaScript pour en faire un langage adapt√© √† l'analyse et la visualisation de donn√©es sur le web.

### üëâ Des biblioth√®ques pr√©charg√©es üìä

OJS c'est du JavaScript + plein de biblioth√®ques pr√© charg√©es : <br/>

| Symbol   | Name              | Version            |
|----------|-------------------|--------------------|
| \_       | Lodash            | 4.17.21            |
| aq       | Arquero           | \${aq.version}     |
| Arrow    | Apache Arrow      | 4.0.1              |
| d3       | D3.js             | \${d3.version}     |
| dot      | Graphviz          | 0.2.1              |
| htl      | Hypertext Literal | \${htl.version}    |
| Inputs   | Observable Inputs | \${Inputs.version} |
| L        | Leaflet           | \${L.version}      |
| mermaid  | Mermaid           | 9.1.6              |
| Plot     | Observable Plot   | \${Plot.version}   |
| SQLite   | SQL.js            | 1.7.0              |
| topojson | TopoJSON Client   | 3.1.0              |
| vl       | Vega, Vega-Lite   | 5.22.1, 5.2.0      |

### üëâ Chaque d√©but de ligne identifie une cellule ojs üôã

Chaque ligne d√©finit une variable et une cellule qui doit √™tre unique sur l'ensemble du document.

``` {{ojs}}
a = 10 // une cellule
b = 20 // une cellule
```

``` {{ojs}}
c = a + b // une cellule
```

``` {{ojs}}
d = { 
  let a = 10 
  let b = 30
  return a + b 
} // Une cellule
```

### üëâ L'ordre des cellules n'a pas d'importance ü§Ø

On peut donc √©crire √ßa

``` {{ojs}}
result = val1 * val2
```

avant √ßa

``` {{ojs}}
val1 = 10
val2 = 20
```

Le lien entre les cellules se fait de fa√ßon topologique et non de haut en bas.

![](fig/topology.png)

### üëâ Tout est r√©actif üî•

D√®s lors qu'une cellule est modifi√©e, les cellules qui en d√©pendent sont modifi√©es √©galement.

Pour modifier la valeutr d'une c√©llule, on utilise des **`Inputs`** (des composants propos√©s par OJS pour explorer les donn√©es) avec le mot cl√© **`viewof`**. Voir : https://observablehq.com/@observablehq/inputs

```{ojs}
viewof x = Inputs.range([0, 255], {step: 1})
```

```{ojs}
viewof y = Inputs.text({value: 30})
```

```{ojs}
viewof z = Inputs.radio([10, 100, 1000], {value: 10})
```

```{ojs}
x * y * z
```

Ce syst√®me est pratique pour modifier des visualisations de donn√©es.

Ici, un exemple avec un simple cercle dessin√© en svg.

```{ojs}
viewof color = Inputs.color({ label: "Couleur", value: "#4ab58c" })
viewof radius = Inputs.range([1, 50], { label: "Rayon", step: 1, value: 100 })
viewof position = Inputs.range([50, 950], { label: "Position", step: 1, value: 50 })
```

```{ojs}
html`<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">
  <circle cx=${position} cy="50" r=${radius} fill="${color}"/>
</svg>`
```

## L'√©cosyst√®me spatial de l'ojs

L'√©cosyst√®me spatial de JavaScript est moins √©toff√© que ce qu'on peut trouver en Python ou en R. Mais on trouve quand m√™me des choses int√©ressantes qui permettent de faire de la g√©omatique directement dans le navigateur web. Voici quelques exemples.

**Les fonctionnalit√©s spatiales de `d3.js`**

::: columns
::: {.column width="8%"}
![](fig/d3.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`d3-geo`**](https://github.com/d3/d3-geo) est le module spatial de d3. Il permet de g√©rer les projections cartographiques, les formes sph√©riques et la trigonom√©trie sph√©rique. Voir aussi [**`d3-geo-projection`**](https://github.com/d3/d3-geo-projection). [**`d3-delaunay`**](https://github.com/d3/d3-delaunay) est une biblioth√®que rapide pour calculer le diagramme de Vorono√Ø d'un ensemble de points bidimensionnels. Elle est bas√©e sur Delaunator, une biblioth√®que rapide pour calculer la triangulation de Delaunay en utilisant des algorithmes de balayage. Le diagramme de Vorono√Ø est construit en reliant les circonf√©rences des triangles adjacents dans la triangulation de Delaunay. [**`d3-geo-voronoi`**](https://github.com/Fil/d3-geo-voronoi) est une adaptation de d3-delaunay sur la sph√®re.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/topojson.svg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`TopoJSON`**](https://github.com/topojson/topojson) est une extension de GeoJSON. La librairie permet de r√©aliser des op√©rations SIG bas√©es sur la topologie (agr√©gation, voisins, simplification, etc.)
:::
:::

**Les biblioth√®ques SIG**

::: columns
::: {.column width="8%"}
![](fig/turf.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`turf`**](https://turfjs.org/) est une biblioth√®que JavaScript pour l'analyse spatiale (de type SIG). Elle comprend les op√©rations spatiales traditionnelles, des fonctions d'aide pour la cr√©ation de donn√©es GeoJSON, ainsi que des outils de classification des donn√©es et de statistiques. L'avantage de turf est d'√™tre modulaire. On ne charge que ce dont on a besoin.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/spljs.jpg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`spl.js`**](https://turfjs.org/) est une impl√©mentation de SpatiaLite (et de ses amis : sqlite, geos, proj, rttopo) pour le navigateur.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/geotoolbox.svg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`geotoolbox`**](https://github.com/neocarto/geotoolbox) est un outil javascript pour les g√©ographes bas√© sur d3geo, topojson et jsts. Il permet de traiter simplement les propri√©t√©s geojson et fournit plusieurs op√©rations SIG utiles pour la cartographie th√©matique.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/gdal.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`Gdals3.js`**](https://github.com/bugra9/gdal3.js) est un portage des applications Gdal (gdal_translate, ogr2ogr, gdal_rasterize, gdalwarp, gdaltransform) vers Webassembly. Il permet de convertir des donn√©es g√©ospatiales matricielles et vectorielles dans divers formats et syst√®mes de coordonn√©es.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/proj4.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`proj4js`**](http://proj4js.org/) est une biblioth√®que JavaScript permettant de transformer les coordonn√©es d'un syst√®me de coordonn√©es √† un autre, y compris les transformations de datum
:::
:::

**Dataviz / cartographie**

::: columns
::: {.column width="8%"}
![](fig/plot.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`plot`**](https://observablehq.com/plot/) est la biblioth√®que de visualisation de donn√©e d√©velopp√©e par Observable (Mike Bostock et Philippe Rivi√®re). Au d√©part pens√©e pour la visualisation de donn√©es statistiques, elle permet aujourd'hui de r√©aliser des cartes. Plot est disponible par d√©faut dans les cellules {ojs}.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/vega.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`vega-lite`**](https://github.com/vega/vega-lite) est un outil de visualisation mettant en ≈ìuvre une grammaire graphique, similaire √† ggplot2. Cette biblioth√®que est disponible par d√©faut dans les cellules {ojs}.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/bertin.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`bertin`**](https://github.com/neocarto/bertin) est une biblioth√®que √©crite en JavaScript qui permet de r√©aliser des cartes th√©matiques pour le web. Sa conception vise √† permettre aux utilisateurs de cr√©er rapidement des cartes th√©matiques interactives sans forcement conna√Ætre le langage JavaScript.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/gridviz.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`Gridviz`**](https://github.com/eurostat/gridviz) est une biblioth√®que JavaScript bas√©e sur WebGL d√©velopp√©e par Julien Gaffuri et Joe Davies. Elle permet de visualiser des donn√©es carroy√©es (ou tout ensemble de donn√©es tabulaires avec une position x/y) dans le navigateur dans une grande vari√©t√© de styles cartographiques.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/logo-go-cart-wasm.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`go-cart-wasm`**](https://github.com/riatelab/go-cart-wasm) est une biblioth√®que JS/WASM permettant de r√©aliser des cartogrammes bas√©s sur le flux (comme d√©crit dans "Gastner, Seguy, and More (2018).
:::
:::

## Importer des donn√©es

Pour importer des donn√©es en **`{ojs}`**, on utilise l'instruction **`FileAttachment()`**

Pour un fichier JSON

``` js
mrc = FileAttachment("geom/mrc.geojson").json()
munic = FileAttachment("geom/munic.geojson").json()
```

Pour un fichier csv

``` js
FileAttachment("data.csv").csv({typed: true})
```
On peut aussi r√©cup√©rer des donn√©es depuis R ou Python avec l'instruction [**`ojs_define`**](https://neocarto.github.io/docs/notebooks/ojsdefine/)

::: {.callout-tip}
## NB
*Souvenez vous que le code JavaScript s'execute dans le navigateur web. Il s'execute donc apr√®s le code R et Python.*
:::

`ojs_define` fonctionne bien pour des simples variables ou des data frames. Mais ne renvoie pas un geoJSON correctement format√© √† partir d'un spatial dataframe.

*chunck r*

```{r}
ojs_define(test = mun)
```

*Chuck ojs*

```{ojs}
test
```

Une solution consiste √† utiliser le package `geojsonsf.`

*Chunck r*

```{r}
library("geojsonsf")
ojs_define(mun = sf_geojson(st_transform(mun, 4326)))
```

`mun` existe desormais dans l'univers ojs et est correctement format√©. Mais c'est une chaine de caractere. On utilisera donc `JSON.parse` pour l'utiliser

*Chunk ojs*

```{ojs}
JSON.parse(mun)
```

```{ojs}
//| eval: true
//| echo: false
tmp = FileAttachment("geom/munic.geojson").json()
munic =  geo.rewind(geo.simplify(tmp, {k:0.1}))
tmp2 = FileAttachment("geom/mrc.geojson").json()
mrc =  geo.rewind(geo.simplify(tmp2, {k:0.1}))

```

## Visualiser les donn√©es statistiques

Pour regarder la table attributaire, on utilise **`Inputs.table()`**

```{ojs}
Inputs.table(munic.features.map(d => d.properties))
```

Avec **`{ojs}`**, on va aussi pouvoir faire des graphiques avec la biblioth√®que **`plot`**. Pour cela, on fait quelques manipulations de donn√©es.

Tout d'abord, on r√©cup√®re les noms des 20 communes les plus peupl√©es, class√©es par ordre d√©croissant de population.

```{ojs}
communes = munic.features
  .map((d) => d.properties)
  .sort((a, b) => d3.descending(a.POP_2022, b.POP_2022))
  .map((d) => d.MUS_NM_MUN)
  .slice(0, 20)
```

```{ojs}
//| echo: false
//| eval: true
communes
```

On met en forme les donn√©es.

```{ojs}
data = {
  let arr = [];
  communes.forEach((d) => {
    let tmp = munic.features
      .map((d) => d.properties)
      .find((x) => x.MUS_NM_MUN == d);
    for (let i = 2001; i <= 2022; i++) {
      arr.push({ year: i, pop: tmp["POP_" + i], com: d });
    }
  });
  return arr;
}
```

```{ojs}
//| echo: false
//| eval: true
Inputs.table(data, {width:250, height:250})
```

Puis on r√©alise le graphique avec `Plot` en proposant de s√©lectionner une commune.

::: {.callout-tip}
## NB
*Plot est directement disponible dans {ojs}. Mais si on souhaite une autre version, on peut l'appeler.*
```{ojs}
Plot = require("@observablehq/plot@0.6.7")
```
*La version 0.6.7 impl√©mente les infobulles.*
:::





```{ojs}
viewof commune = Inputs.select(communes, { label: "Commune" })
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population (${commune})`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data.filter(d => d.com == commune), {
      x: "year",
      y: "pop",
      stroke: "red",
      strokeWidth: 2
    })
  ]
})
```

On peut √©galement mettre toutes les courbes sur un graphique

```{ojs}
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data, {
      x: "year",
      y: "pop",
      stroke: "com",
      strokeWidth: 2,
      tip: true
    })
  ]
})
```

Ou en normalisant

```{ojs}
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population`
  },
  marginLeft: 60,
  marks: [
    Plot.lineY(data, Plot.normalizeY("first",{
      x: "year",
      y: "pop",
      stroke: "com",
      strokeWidth: 2,
      tip: true
    }))
  ]
})
```

## Visualiser les g√©om√©tries

Comme leaflet est disponible dans les cellules {ojs}, on peut directement afficher les g√©om√©tries.

```{ojs}
{
  const container = yield htl.html`<div style="height: 500px;">`;
  const map = L.map(container);
  const layer = L.geoJSON(mrc).addTo(map);
  map.fitBounds(layer.getBounds(), { maxZoom: 9 });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution:
      "¬© <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors"
  }).addTo(map);
}
```

On peut √©galement afficher la carte simplement avec la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin).

```{ojs}
bertin = require("bertin")
```

```{ojs}
bertin.quickdraw(mrc)
```

## Un peu de SIG

La bibioth√®que **`geotoolbox`** permet de faire facilement differentes operations SIG.

```{ojs}
geo = require("geotoolbox")
```

-   **Simplification**

```{ojs}
viewof simpl = Inputs.range([0.0001, 0.2], { label: "Simplification",  value: 0.1 })
mrc2 = geo.simplify(mrc, { k: simpl })
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: munic},layers:[{geojson: mrc2, stroke:"black", strokeWidth:1.5, fill:"white", rewind: true}]})
```

-   **Centroid**

```{ojs}
ctr = geo.centroid(mrc)
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: mrc}, layers:[{geojson: ctr, fill:"red"},{geojson: mrc, fill:"#CCC"}, ]}) 
```

-   **Buffer**

```{ojs}
quebec = geo.filter(mrc, (d) => d.MUS_CO_MRC == "23")
buff = geo.buffer(quebec, { dist: distance})
ctr2 = geo.clip(ctr, {clip: buff})
```

```{ojs}
//| echo: false
viewof distance = Inputs.range([0, 500], {
  label: "Distance",
  value: 300,
  step: 10
})
bertin.draw({layers:[{geojson: quebec, fill:"red"}, {geojson: ctr2, fill:"red"}, {geojson: buff, stroke:"red", fill: "none", strokeWidth:2},{geojson: mrc, fill:"#CCC"}, ]}) 
```

## Cartographie th√©matique

Pour cr√©er des cartes th√©matiques, on peut utiliser la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin)

La fonction **`draw`** permet de r√©aliser n'importe quel type de carte.

![](fig/bertin_code.png)

Par d√©faut, la couche s'affiche simplement.

```{ojs}
bertin.draw({layers:[{geojson: munic, fill: "#d18de0"}]})
```

On peut ajouter l'attrubut **`tooltip`** pour afficher des infobulles.

```{ojs}
bertin.draw({
  layers:[
    { 
      geojson: munic, fill: "#d18de0",
      tooltip: "$MUS_NM_MUN"
    }
  ]
})
```

**Cartographie th√©matique**

A pr√©sent, r√©alisons une carte de la population en 2022. Pour cela, on utilise le type **`bubble`**.

Par d√©faut, √ßa donne ceci :

```{ojs}
bertin.draw({
    layers: [
      {
        type: "bubble",
        geojson: munic, 
        values: "POP_2022", 
        fill:"red"
      },
      {
        geojson: munic,
        fill: "#CCC"
      }, 
  ]
})
```

Et en param√©trant un peu, on obtient ceci.

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", //  identifiant de la couche
      type: "bubble", // couche de symboles proportionnels
      geojson: munic, 
      values: "POP_2022", // variable √† cartographier 
      k: 50, // Rayon du plus gros cercle
      leg_x: 740,
      leg_y: 350,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] // infobulle
    },
    {geojson: munic, fill:"#CCC"}, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut facilement combiner cette couche de cercles avec un une carte choropl√®the.

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "white",
      fillOpacity:0.2,
      stroke:"black",
      strokeWidth:1.4,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalit√©\n√©conomique",
            leg_round: 2
        }
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut aussi colorier les cercles

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalit√©\n√©conomique",
            leg_round: 2
        },
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: "#CCC"
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut utiliser les **`Inputs`** pour tester des visualisations, explorer les donn√©es ou proposer des interactions √† un utilisatuer.

```{ojs}
// Inputs
viewof symbology = Inputs.radio(["bubble", "square", "spikes", "smooth", "dotdensity"], { label: "symbologie",   value: "bubble"})
viewof r = Inputs.range([10, 100], { label: "taille", step: 1, value: 50, disabled : ["bubble", "square", "spikes"].includes(symbology) ? false: true})
viewof toggle = Inputs.toggle({label: "dorling", value: false, disabled : ["bubble", "square", "dotdensity"].includes(symbology) ? false: true})
viewof thresholds = Inputs.range([5, 50], { label: "thresholds", step: 1, value: 23, disabled : symbology == "smooth" ? false : true})
viewof bandwidth = Inputs.range([5, 50], { label: "bandwidth", step: 1, value: 27, disabled : symbology == "smooth" ? false : true })
viewof filterpop = Inputs.range([1000, 100000], { label: "POP >= ", step: 1, value: 1000})
// Carte
bertin.draw({
    params: { extent: [[-79, 44.5], [-66, 51]]},
    layers: [
      {
        type: symbology,
        geojson: geo.filter(munic, (d) => d.POP_2022 >= filterpop), 
        values: "POP_2022", 
        fill: symbology == "smooth" ? "RdYlGn" : "red",
        fillOpacity:0.7,
        dorling: toggle,
        k: r,
        thresholds,
        bandwidth,
        symbol_size:25,
        w:15,
        symbol_shift : toggle ? 1 : 0,
        stroke : symbology == "spikes" ? "red" : "white",
        tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
      },
      {
        geojson: munic,
        fill: "#CCC",
        stroke : toggle ? "#CCC" : "white"
      }, 
  ]
})
```

## R√©f√©rences

<ins>Documentation</ins>

-   [github.com/neocarto/bertin](https://github.com/neocarto/bertin)

<ins>Exemples</ins>

-   [observablehq.com/\@neocartocnrs/bertin-js-tooltips?collection=\@neocartocnrs/bertin](https://observablehq.com/@neocartocnrs/bertin-js-tooltips?collection=@neocartocnrs/bertin)

<ins>Bibliographie</ins>

-   **Bostock M. (2021) JavaScript for Data Analysis. towardsdatascience. [towardsdatascience.com/javascript-for-data-analysis-2e8e7dbf63a7](https://towardsdatascience.com/javascript-for-data-analysis-2e8e7dbf63a7)**
-   Bostock M., Ogievetsky V., Heer J. (2011). D¬≥ Data-Driven Documents, IEEE, Volume: 17 [ieeexplore.ieee.org/abstract/document/6064996](https://ieeexplore.ieee.org/abstract/document/6064996)
-   Giraud T., Lambert N., (2023). bertin: Thematic Cartography with 'bertin.js'. [github.com/riatelab/bertin/, https://riatelab.github.io/bertin](https://github.com/riatelab/bertin/,%20https://riatelab.github.io/bertin)
-   **Lambert N, Giraud T, Viry Matthieu and, Ysebaert R. (2023) Cartographier pour le web avec la biblioth√®que JavaScript 'bertin'. SAGEO**
-   Lambert N. (2023) Observable en bref. Webinaire 'Interroger les donn√©es', Groupe de travail 'Atelier Donn√©es' du CNRS.
-   Lambert N., Zanin C., (2020). Practical handbook of thematic cartography: principles, methods, and applications. CRC Press. [observablehq.com/\@neocartocnrs/webinaire-interroger-les-donnees](https://observablehq.com/@neocartocnrs/webinaire-interroger-les-donnees)
-   Lambert N. (2023) Cartographie th√©matique avec ojs. √âcole d'√©t√© internationale, Ouidah. [https://ee-cist.github.io/CAR2_cartodyn/intro/docs/index.html](ee-cist.github.io/CAR2_cartodyn/intro/docs/index.html%5D)
-   **Perkel M. J. (2021) Reactive, reproducible, collaborative: computational notebooks evolve, Nature. [nature.com/articles/d41586-021-01174-w](https://www.nature.com/articles/d41586-021-01174-w)**
-   Rice J., Farquhar A., Piernot P., Gruber T., (1996). "Using the Web instead of a window system". In: Proceedings of the SIGCHI conference on Human factors in computing systems common ground - CHI '96. the SIGCHI conference. Vancouver, British Columbia, Canada: ACM Press, pp. 103--110. isbn: 978-0-89791-777-3. doi: 10.1145/238386.238442.
-   Roth R.E., Donohue R.G., Sack C.M., Wallace T.R., Buckingham T.M.A., (2015). "A Process for Keeping Pace with Evolving Web Mapping Technologies". In: Cartographic Perspectives 78, pp. 25--52. issn: 1048-9053. doi: 10.14714/CP78.1273. url: https://cartographicperspectives.org/index.php/journal/article/view/cp78-roth-et-al
-   Shen H. (2014). Interactive notebooks: Sharing the code. Nature, 515(7525), 151-152.

# A vous de jouer

::: {.callout-caution appearance="simple"}
## faire des cartes avec {ojs}

::: {.callout-note icon="false"}
## Objectif

R√©aliser comme ci-dessous, une carte [choropl√®the](http://geoconfluences.ens-lyon.fr/glossaire/choroplethe-choroisoplethe) sur une r√©gion du Qu√©bec que l'on peut selectionner dans une liste d√©roulante.

```{ojs}
//| echo: false
//| eval: true
viewof myregion =  Inputs.select(["Estrie","Capitale-Nationale","Bas-Saint-Laurent"], {label: "Choisissez une r√©gion"})
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
bertin.draw({ layers: [{type:"header", text: `Les actifs (${myregion})`},{type:"scalebar"},{ geojson: myreg, rewind: true, fill: {type:"choro", values: "TX_2564", colors: "RdYlGn", leg_x: 2, leg_y:2, leg_title:"Taux d'actifs", leg_round:1}, tooltip:["$MUS_NM_MUN", d => "Taux d'actifs :" + d.properties.TX_2564 + "%"]}] })
```
:::

**A vous de jouer**

-   Chargez la biblioth√®que [`bertin`](https://github.com/neocarto/bertin)
-   Importez la couche `munic.geojson`

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Pour importer des donn√©es au format JSON en Observable JavaScript, on utilise l'instruction `FileAttachment()`
:::

-   Afficher le fond de carte avec la fonction [`draw`](https://github.com/neocarto/bertin#drawing-a-map)

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

La fonction draw prend en entr√©e un objet qui a la structure suivante :

``` js
bertin.draw({
  layers: [{...}]
})
```
:::

::: {.callout-tip icon="false" collapse="true"}
## Astuce

Si la carte ne s'affiche pas correctement, utiliser l'attribut `rewind:true`
:::

-   Afficher les donn√©es attributaires.

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

On peut afficher les donn√©es avec l'instruction. `Inputs.table()` Mais auparavant, il faut r√©cup√©rer les propri√©t√©s du geoJSON comme ceci :

``` js
munic.features.map((d) => d.properties)
```
:::

-   Cr√©er une liste d√©roulante pour choisir parmi 3 r√©gions √† √©tudier

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Par exemple :

``` js
mesregions = ["Estrie","Capitale-Nationale","Bas-Saint-Laurent"]
viewof myregion =  Inputs.select(mesregions, {label: "Choisissez une r√©gion"})
```
:::

-   Cr√©ez un nouveau fond de carte contenant les municipalit√©s de la r√©gion concern√©e.

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Pour cr√©er ce sous jeu de donn√©es, on peut utiliser la fonction `subset` de la biblioth√®que `bertin`.

``` js
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
```
:::

-   Afficher le nouveau fond de carte
-   D√©finisser la couleur de fond, l'√©paisseur des traits, la couleur des contours.
-   R√©aliser une carte [chorpl√®the](https://github.com/neocarto/bertin#choropleth) √† partir d'une variable disponible. Par exemple, le taux d'actifs (TX_2564).

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

D√©finissez l'attribut `fill` par un objet commen√ßant par `{type: choro, values: ...}`
:::

-   Changez les couleurs et la m√©thode de discretisation

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

La documentation est disponible [ici](https://github.com/neocarto/bertin#choropleth)
:::

-   Ajouter un [titre](https://github.com/neocarto/bertin#header)
-   Ajouter la l√©gende
-   Ajouter l'[√©chelle](https://github.com/neocarto/bertin#scalebar)
-   Ajoutez des [infobulles](https://observablehq.com/@neocartocnrs/bertin-js-tooltips)

::: {.callout-caution collapse="true"}
## SOLUTION

```{ojs}
//| echo: true
//| eval: false
bertin = require("bertin")
munic = FileAttachment("munic.geojson").json()
viewof myregion = Inputs.select(
  ["Estrie", "Capitale-Nationale", "Bas-Saint-Laurent"],
  { label: "Choisissez une r√©gion" }
)
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
bertin.draw({
  layers: [
    { type: "header", text: `Les actifs (${myregion})` },
    { type: "scalebar" },
    {
      geojson: myreg,
      rewind: true,
      fill: {
        type: "choro",
        values: "TX_2564",
        colors: "RdYlGn",
        leg_x: 2,
        leg_y: 2,
        leg_title: "Taux d'actifs",
        leg_round: 1
      },
      tooltip: [
        "$MUS_NM_MUN",
        (d) => "Taux d'actifs :" + d.properties.TX_2564 + "%"
      ]
    }
  ]
})
```
:::
:::


## Le petit plus : d√©p√¥t et d√©ploiement continu avec GitHub.
