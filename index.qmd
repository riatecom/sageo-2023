---
title: "Articulation de diff√©rents langages (R, JavaScript et Python) pour la g√©ovisualisation avec Quarto"
subtitle: "Atelier Sageo, Qu√©bec, Juin 2023"
author: 
  - name: "Timoth√©e Giraud, Nicolas Lambert, Matthieu Viry, Ronan Ysebaert"
    affiliations:
      - id: 1
        name: RIATE (CNRS, Universit√© Paris Cit√©)
        url: https://riate.cnrs.fr
format:
  html:
    theme: sandstone
    fontsize: 0.9em
    code-tools: true
    toc: true
    toc-depth: 2
    linkcolor: "#8631ad"
execute: 
  cache: false
editor_options: 
  chunk_output_type: console
bibliography: references.bib
csl: "universite-de-montreal-apa.csl"
lang: fr
resources: "quebec.zip"

---

![](fig/SAGEO.png)

## Pr√©sentation

Dans un contexte d'essor de carnets interactifs (*notebooks*), l'objet de cet atelier consiste √† montrer les possibilit√©s offertes par Quarto, un syst√®me de publication scientifique et technique open source bas√© sur Pandoc, qui permet d'articuler diff√©rents langages pour r√©aliser des g√©ovisualisations reproductibles dans un seul et m√™me document. Cet atelier proposera aux participants une prise en main des principales fonctionnalit√©s offertes par Quarto, puis une mise en ≈ìuvre de cha√Ænes de traitements de l'information g√©ographique reproductibles avec R, Python et Observable JavaScript dans cet environnement.

### D√©roul√© de la demi-journ√©e

-   Installation des logiciels n√©cessaires √† la mise en place de l'environnement de d√©veloppement (Quarto, R, Python, RStudio, etc.).
-   Pr√©sentation et prise en main des principales fonctionnalit√©s des notebooks Quarto. Pr√©sentation des √©cosyst√®mes spatiaux de R et Python, et, d'un jeu de donn√©es commun sur lequel s'appuiera l'ensemble de l'atelier.
-   Traitement des donn√©es vectorielles : Mise en pratique d'une cha√Æne de traitements reproductible avec R, notamment gr√¢ce aux packages `sf` et `mapsf.`
-   Traitement des donn√©es raster : Mise en pratique d'une cha√Æne de traitements reproductible avec Python (biblioth√®ques `geopandas`, `rasterio`, `xarray`, `matplotlib`, etc.).
-   Cr√©ation de visualisations cartographiques interactives avec ojs (biblioth√®ques `bertin`, `Plot`, `Gridviz`, `Deck.gl`).
-   Export du document quarto produit pendant l'atelier (templates de diff√©rentes revues scientifiques, slides, https://quartopub.com/, etc.).


## Donn√©es atelier

**Vecteur**

-   [OpenStreetMap](https://www.openstreetmap.org/) (POI) : restaurants.
-   Le d√©coupage g√©ographique des municipalit√©s qu√©b√©coises (Source : [Minist√®re des Ressources naturelles et des For√™ts](https://mrnf.gouv.qc.ca/repertoire-geographique/carte-generale-base-donnees-geographiques-administratives/)).
-   La s√©rie de population 2001-2022 et l'indice de vitalit√© √©conomique des localit√©s qu√©becoises, d√©livr√© par l'[Institut de la Statistique du Qu√©bec](https://statistique.quebec.ca/fr/recherche?territoire=municipalites&type_produit=tableau-detaille).

**Raster** 

- Couverture du sol : [Comptes des terres du Qu√©bec M√©ridional](https://www.donneesquebec.ca/recherche/fr/dataset/comptes-des-terres-du-quebec-meridional-changement-de-la-couverture-terrestre) (ann√©es de capture entre 2002 et 2013 selon les r√©gions administratives).


::: {.callout-caution}
## T√©l√©charger les donn√©es de l'exercice

Toutes les donn√©es mobilis√©es dans cet atelier son stock√©es dans un projet RStudio. Vous devez le t√©l√©charger puis le d√©compresser sur votre machine. Il vous sera ensuite possible de tester l'ensemble des manipulations propos√©es dans ce document au sein du projet **quebec**.  
[T√©l√©charger le projet](quebec.zip){.btn .btn-primary .btn-sm role="button"}  

:::

## Pr√©paration des donn√©es

Dans cet atelier nous allons utiliser des donn√©es portant sur les municipalit√©s du Qu√©bec. Dans un premier temps nous avons pr√©par√© et nettoy√© les donn√©es avec le logiciel R. 
Les diff√©rentes √©tapes de pr√©paration sont d√©crites dans le script suivant.  

```{r}
#| eval: false
#| code-fold: true
library(sf)
library(mapsf)
library(readxl)
library(rmapshaper)

# Communes
mun <- st_read("data-raw/munic_s.shp", quiet = TRUE)
# Transformation conique √©quivalente d'ALbers
mun <- st_transform(mun, 6623)
# Suppression des surfaces en eau
mun <- mun[!is.na(mun$MUS_CO_GEO),]
# Selection des variables pertinentes
mun <- mun[, c("MUS_CO_GEO", "MUS_NM_MUN", "MUS_CO_MRC", "MUS_NM_MRC", "MUS_NM_REG")]
# Simplifier les contours des polygones
mun <- ms_simplify(mun, )

# Agregation des multipolygones
mun <- aggregate(x = mun[, -1], 
                 by = list(MUS_CO_GEO = mun$MUS_CO_GEO),
                 FUN = head, 1)
mun <- st_cast(mun, "MULTIPOLYGON")

# Import donn√©es population et nettoyage
df <- read_xlsx("data-raw/stats_socio_eco/Pop-MUN-total.xlsx", 
                skip = 3, n_max = 1292,
                col_types = c(rep("text", 2),"numeric",rep("text", 4), 
                              rep("numeric", 22))) 
df <- as.data.frame(df)
df <- df[,c(1:3, 8:29)]
col_pop <- paste0("POP_", seq(2001, 2022, 1))
colnames(df) <- c("NOM", "STATUT", "MUS_CO_GEO", col_pop)
df$MUS_CO_GEO <- formatC(df$MUS_CO_GEO, width = 5, flag = "0", format = "d")

mun <- merge(mun, df, by = "MUS_CO_GEO", all.x = T)


# Import donn√©es socio-√©co et nettoyage
df2 <- data.frame(read_xlsx("data-raw/stats_socio_eco/Tableau.xlsx", 
                            skip = 4, n_max = 1163))
df2 <- df2[-c(1:2),]
df2 <- df2[,c(2:4,6,8,10)]
colnames(df2) <- c("NOM", "REG", "VIT_ECO", "REV_MED", "TX_2564", "TAAM")
df2$id <- paste0(df2$NOM, "_", df2$REG)

df2$VIT_ECO <- as.numeric(df2$VIT_ECO)
df2$REV_MED <- as.numeric(df2$REV_MED)
df2$TX_2564 <- as.numeric(df2$TX_2564)
df2$TAAM <- as.numeric(df2$TAAM)
mun$id <- paste0(mun$NOM, " (", mun$STATUT, ")_", mun$MUS_NM_REG)
mun <- merge(mun, df2, by = "id", all.x = TRUE)
mun <- mun[, c(2:6, 8:30, 33:36)]



# agregation de municipalit√© en Municipalit√© r√©gionale de comt√© (MRC)
mun <- st_set_precision(mun, 1)
mrc <- aggregate(mun[, c("MUS_NM_MRC","MUS_NM_REG")], 
                 by = list(MUS_CO_MRC = mun$MUS_CO_MRC),
                 FUN = head, 1)
mrc <- st_cast(mrc, "MULTIPOLYGON")
mun <- st_set_precision(mun, 0)

st_write(st_transform(mrc, 4326), "data/mrc.geojson")
st_write(st_transform(mun, 4326), "data/munic.geojson")
```

Ce script abouti √† la cr√©ation de deux fichiers :

- `mrc.geojson` est un fond de carte des Municipalit√© R√©gionales de Comt√©. 
- `munic.geojson` et un fond de carte des municipalit√©s contenant des donn√©es socio-d√©mographiques. 


# R

## L'√©cosyst√®me spatial de R

Le logiciel R [@R-base] permet depuis longtemps de traiter et repr√©senter les donn√©es spatiales.  
Le principal package permettant de traiter les donn√©es vectorielles avec R est le package `sf` [@R-sf].  
Les packages `stars` [@pebesma2023] et `terra` [@R-terra] quand √† eux sont les principaux packages d√©di√©s au traitement des donn√©es raster.

Les d√©veloppements actuels s'appuient sur ce socle et forment un √©cosyst√®me robuste qui offre aux utilisateurs la plupart des fonctionnalit√©s autrefois r√©serv√©es aux Syst√®mes d'Information G√©ographique.  
Le package `mapsf` [@R-mapsf] par exemple s'appuie sur le package `sf` pour cr√©er des cartes th√©matiques. D'autres packages sont d√©di√©s √† la cartographie interactive, aux statistiques spatiales, l'interaction avec des API de cartographie, la cr√©ation de cartogrammes etc.

## Le package `sf`

<img src="fig/logo_sf.gif" align="right" width="150"/>

Le package `sf` a √©t√© publi√© fin 2016 par Edzer Pebesma. Ce package permet l'import, l'export, la manipulation et l'affichage de donn√©es spatiales vectorielles. Pour cela `sf` s'appuie sur une s√©rie de biblioth√®ques spatiales : GDAL [@GDAL] et PROJ [@PROJ] pour les op√©rations d'import, d'export et de projection, et GEOS [@GEOS] pour les op√©rations de g√©otraitement (buffer, intersection...).  
Ce package propose des objets simples (suivant le standard [*simple feature*](https://en.wikipedia.org/wiki/Simple_Features)) dont la manipulation est assez ais√©e. Une attention particuli√®re a √©t√© port√©e √† la compatibilit√© du package avec la syntaxe *pipe* (`|>` ou `%>%`) et les op√©rateurs du `tidyverse` [@R-tidyverse].

![@pebesma2023](fig/sf_deps.png)

::: callout-note
## Historique

Le package `sf` est venu remplacer les packages `sp` [@R-sp], `rgeos` [@R-rgeos] et `rgdal` [@R-rgdal] en combinant leurs fonctionnalit√©s dans un package unique plus ergonomique.
:::

::: panel-tabset
```{r knit_init}
#| include: false
#| cache: false
knitr::knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  } 
})
knitr::opts_chunk$set(nm=TRUE, echo=TRUE)
```

### Format

![Format des objets spatiaux `sf`](fig/sf.png)

Les objets `sf` sont des `data.frame` dont l'une des colonnes contient des g√©om√©tries.  
Ce format est tr√®s pratique dans la mesure ou les donn√©es et les g√©om√©tries sont intrins√®quement li√©es dans un m√™me objet.

::: callout-note
## Vignette d√©crivant le format simple feature

[Simple Features for R](https://r-spatial.github.io/sf/articles/sf1.html)
:::

### Import

```{r sf_import_fake}
#| eval: false
library(sf)
mtq <- st_read(dsn = "data/mtq.gpkg", layer = "mtq")
```

```{r sf_import}
#| include: false
library(sf)
library(mapsf)
mtq <- mf_get_mtq()
```

### Affichage

```{r sf_plot, fig.height=3, fig.width=3, nm=TRUE}
plot(st_geometry(mtq))
```

```{r sf_plot_multi, fig.height=4, fig.width=7, nm=TRUE}
plot(mtq)
```

### Centroides

```{r sf_centro,  fig.height=3, fig.width=3, nm=TRUE, warning=FALSE}
mtq_c <- st_centroid(mtq)
plot(st_geometry(mtq))
plot(st_geometry(mtq_c), cex = 1.2, col = "red", pch = 20, add = TRUE)
```

### Matrice de distance

```{r sf_matrix,  fig.height=3, fig.width=3, nm=TRUE}
mat <- st_distance(x = mtq_c, y = mtq_c)
mat[1:5, 1:5]
```

### Ag√©regation

```{r sf_agg,  fig.height=3, fig.width=3, nm=TRUE}
mtq_u <- st_union(mtq)
plot(st_geometry(mtq), col = "lightblue")
plot(st_geometry(mtq_u), lwd = 2, border = "red", add = TRUE)
```

### Zone tampon

```{r sf_buff,  fig.height=3, fig.width=3, nm=TRUE}
mtq_b <- st_buffer(x = mtq_u, dist = 5000)
plot(st_geometry(mtq_b), col = "grey", lwd = 2, border = "red")
plot(st_geometry(mtq), col = "lightblue", add = TRUE)
plot(st_geometry(mtq_u), lwd = 2, add = TRUE)
```

### Intersection

```{r sf_interse,  fig.height=3, fig.width=3, nm=TRUE, echo=FALSE}
m <- rbind(c(700015,1624212), c(700015,1641586), 
           c(719127,1641586), c(719127,1624212), 
           c(700015,1624212))
p <- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(mtq))
plot(st_geometry(mtq))
plot(p, border="red", lwd=2, add=T)
text(719127,1641586, "p", pos = 4, cex = 3)
```

```{r sf_intersect2,  fig.height=3, fig.width=3, nm=TRUE, warning=F}
#| layout-ncol: 2
mtq_z <- st_intersection(x = mtq, y = p)
plot(st_geometry(mtq))
plot(st_geometry(mtq_z), col = "red", border = "green", add = TRUE)
plot(st_geometry(mtq_z), lwd = 2)
```

### Polygones de Voronoi

```{r sf_voronoi,  fig.height=3, fig.width=3, nm=TRUE}
mtq_c |> 
  st_union() |> 
  st_voronoi() |> 
  st_collection_extract("POLYGON") |> 
  st_intersection(mtq_u) |> 
  st_sf() |> 
  st_join(mtq_c, st_intersects) |>
  st_cast("MULTIPOLYGON") |>
  st_geometry() |>
  plot(col = "ivory4")
```
:::


## Le package `mapsf`

<img src="fig/logo_mapsf.png" align="right" width="150px"/>

`mapsf` permet de cr√©er la plupart des types de carte utilis√©s habituellement en cartographie statistique.  
Pour chaque type de carte, plusieurs param√®tres permettent de personnaliser la repr√©sentation cartographique. Ces param√®tres sont les m√™mes que ceux que l'on retrouve dans les logiciels de SIG ou de cartographie usuels.  
Associ√©es aux fonctions de repr√©sentation des donn√©es d'autres fonctions sont d√©di√©es √† l'habillage cartographique, √† la cr√©ation de cartons ou √† l'export des cartes.  
`mapsf` est le successeur de [`cartography`](http://riatelab.github.io/cartography/docs/) [@R-cartography], il offre les m√™mes fonctionnalit√©s principales tout en √©tant plus l√©ger et plus ergonomique.

![Cha√Æne de traitement typique](fig/workflow.png)

::: panel-tabset
### Types de carte

::: {layout="[[1,1,1], [1,1,1]]"}
![](fig/map01.png)

![](fig/map02.png)

![](fig/map03.png)

![](fig/map04.png)

![](fig/map05.png)

![](fig/map06.png)

![](fig/map07.png)

![](fig/map08.png)

![](fig/map09.png)
:::

### Utilisation simple

```{r mapsf_simple}
#| fig-width: 5
#| fig.height: 6
library(mapsf)
# Import the sample dataset
mtq <- mf_get_mtq()
# Plot the base map
mf_map(x = mtq)
# Plot proportional symbols
mf_map(x = mtq, var = "POP", type = "prop")
# Plot a map layout
mf_layout(title = "Population in Martinique", 
          credits = "T. Giraud; Sources: INSEE & IGN, 2018")
```

### Utilisation avanc√©e

```{r mapsf_avance}
#| results: hide
# Export a map with a theme and extra margins 
mf_export(x = mtq, filename = "fig/mtq.svg",  width = 5, 
          theme = "green", expandBB = c(0,0,0,.3)) 
# Plot a shadow
mf_shadow(mtq, col = "grey10", add = TRUE)
# Plot a choropleth map
mf_map(x = mtq, var = "MED", type = "choro",
       pal = "Dark Mint", 
       breaks = "quantile", 
       nbreaks = 6, 
       leg_title = "Median Income\n(euros)", 
       leg_val_rnd = -2, 
       add = TRUE)
# Start an inset map
mf_inset_on(x = "worldmap", pos = "right")
# Plot mtq position on a worldmap
mf_worldmap(mtq, col = "#0E3F5C")
# Close the inset
mf_inset_off()
# Plot a title
mf_title("Wealth in Martinique, 2015")
# Plot credits
mf_credits("T. Giraud\nSources: INSEE & IGN, 2018")
# Plot a scale bar
mf_scale(size = 5)
# Plot a north arrow
mf_arrow('topleft')
dev.off()
```

![](fig/mtq.svg){width="500px"}

```{r reset_theme}
#| include: false
mf_theme("default")
```
:::

::: callout-note
D'autres packages peuvent √™tre utilis√©s pour r√©aliser des cartes th√©matiques.  
Le package `ggplot2` [@R-ggplot2], en association avec le package `ggspatial` [@R-ggspatial], permet par exemple d'afficher des objets spatiaux et de r√©aliser des cartes th√©matiques simples.  
Le package `tmap` [@R-tmap] est d√©di√© √† la cr√©ation de cartes th√©matiques, il utilise une syntaxe proche de celle de `ggplot2` (encha√Ænement d'instructions combin√©es avec le signe `+`).  
La documentation et les tutoriels pour utiliser ces deux packages sont facilement accessibles sur le web.
:::

## Ressources

[Geocomputation with R](https://r.geocompx.org/) - @lovelace2019

[Spatial Data Science with applications in R](https://r-spatial.org/book/) - @pebesma2023

[Spatial Data Science with R and "terra"](https://rspatial.org/) - Robert J. Hijmans

[Progress in the R ecosystem for representing and handling spatial data](https://link.springer.com/article/10.1007/s10109-020-00336-0) - @bivand2021

[Cartographie avec R](https://rcarto.github.io/cartographie_avec_r/) - @Giraud_Cartographie_avec_R_2023

[G√©omatique avec R](https://rcarto.github.io/geomatique_avec_r/) - @Giraud_Geomatique_avec_R_2023

[CRAN Task View: Analysis of Spatial Data](https://cran.r-project.org/web/views/Spatial.html)

[R Special Interest Group on using Geographical data and Mapping](https://stat.ethz.ch/mailman/listinfo/r-sig-geo) (mailing list)

## Exemples d'analyse sur les donn√©es du Qu√©bec

### Import et pr√©paration des donn√©es

Nous utilisons le package `sf` pour importer 2 fichiers geojson.  
Il est ensuite possible de changer la projection des couches avec la fonction `st_transform()`.  
Nous pouvons aussi cr√©er une couche des r√©gions du Qu√©bec en agr√©geant les Municipalit√© R√©gionales de Comt√©.

```{r import}
#| message: false
# Import des donn√©es
library(sf)
mun_raw <- st_read("data/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("data/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
epsg_6623 <- "EPSG:6623"
mun <- st_transform(mun_raw, epsg_6623)
mrc <- st_transform(mrc_raw, epsg_6623)
# Cr√©ation d'une couche des r√©gions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
```

### Premi√®re cartographie simple

Sur cette premi√®re carte nous allons simplement afficher les diff√©rentes couches en les superposant.  
Nous utilisons le package `mapsf` qui permet aussi de cr√©er une couche d'√©tiquettes avec la fonction `mf_label()`.

```{r carto_quebec_reg}
#| fig-width: 8
#| fig-height: 10.05
library(mapsf)
mf_map(mun, border = "white")
mf_map(mrc, col = NA, border = "grey70", lwd = 1, add = TRUE)
mf_map(reg, col = NA, border = "black", lwd = 1.2, add = TRUE)
mf_label(reg, var = "MUS_NM_REG", halo = TRUE, overlap = FALSE)
mf_scale(size = 100)
mf_title("Le Qu√©bec")
mf_credits(txt = "Minist√®re des Ressources naturelles et des For√™ts, 2023", 
           bg = "#ffffffCC")
```

### O√π sont les restaurants dans la ville de Qu√©bec?

Nous voulons savoir dans quelles zones de la ville de Qu√©bec se trouvent les restaurants.  
Pour conna√Ætre la position des restaurants dans la ville nous allons extraire des informations la base de donn√©s cartographique libre OpenStreetMap avec le package `osmdata` [@R-osmdata]. Le package `osmdata` utilise l'API du service [Overpass turbo](https://overpass-turbo.eu/) pour extraire des donn√©es vectorielles de la base de donn√©es OpenStreetMap.

Nous devons tout d'abord d√©finir une emprise spatiale √† partir de laquelle nous pourrons extraire les informations sur les restaurants.  
Apr√®s avoir d√©marr√© les packages n√©cessaires, nous allons tout d'abord s√©lectionner la MRC de Qu√©bec dans la couche des MRC.

```{r target_city}
#| message: false
library(sf)
library(osmdata)
nom_mrc <- "Qu√©bec"
target <- mrc[mrc$MUS_NM_MRC == nom_mrc, ]
```

Nous allons ensuite d√©finir une *bounding box* correspondant √† l'emprise de la MRC. Le package `osmdata` fonctionne avec des objets en WGS84 nous avons donc besoin de reprojeter les donn√©es.

```{r create_bb}
# Reprojection en WGS84
target_4326 <- st_transform(target, "EPSG:4326")
# Cr√©ation de la bounding box
bbox <- st_bbox(target_4326)
```

Nous pouvons maintenant d√©finir ce que nous voulons extraire de la base de donn√©e OSM. Une connaissance de la structuration de la base de donn√©es OSM est n√©cessaire ([Wiki OpenStreetMap](https://wiki.openstreetmap.org/wiki)). Nous utilisons le syst√®me de clef/valeur pour construire la requ√™te.

```{r define_request}
# Initialisation de la requ√™te √† envoyer
q <- opq(bbox = st_bbox(bbox))
# Choix des objets √† extraire
req <- add_osm_feature(opq = q, 
                       key = 'amenity', 
                       value = "restaurant")


```

La fonction `osmdata_sf()` permet d'envoyer la requ√™te et de recevoir les r√©sultats sous forme de `data.frame` `sf`.

```{r send_request}
#| cache: true
# Reception de la requete
res <- osmdata_sf(q = req)
res
```

Ce r√©sultat contient des restaurants repr√©sent√©s par de points (*osm_points*) et d'autre repr√©sent√©s par des polygones (*osm_polygons*). La couche des points contient √©galement les points qui composent les polygones de la couche de polygones. La fonction `unique_osmdata()` permet de filtrer ces "doublons".

```{r filter_osm}
# Reduction du resultats 
# (les points composant les polygones sont supprim√©s)
res <- unique_osmdata(res)
res
```

L'√©tape suivante consiste √† utiliser extraire les points et les polygones, puis √† extraire les centroides des polygones pour constituer une couche de points compl√®te.

```{r build_layer}
#| warning: false
# Extraction des points
resto_point <- res$osm_points
# Extraction des polygones
resto_poly <- res$osm_polygons
# Transformation des polygones en points (centroides)
resto_poly_point <- st_centroid(resto_poly)
# Listes des champs √† conserver
chps <- c("osm_id", "name", "cuisine")
# Rassembler les 2 couches de points
resto <- rbind(resto_point[, chps], resto_poly_point[, chps])
resto
```

Maintenant que nous avons cette couche de restaurants nous allons pouvoir l'afficher.  
Pour cela nous pouvons utiliser un fond de carte issues de tuiles raster gr√¢ce au package `maptiles` [@R-maptiles]. Nous allons d'abord reprojeter les diff√©rentes couches d'information en Web/Mercator (EPSG:3857) car les tuiles raster sont fournies dans cette projection .

```{r reproj_layers}
target <- st_transform(target, "EPSG:3857")
resto <- st_transform(resto, "EPSG:3857")
```

Nous pouvons maintenant t√©l√©charger les tuiles raster grace √† la fonction `get_tiles()`.

```{r get_tiles}
library(maptiles)
tiles <- get_tiles(x = target, 
                   provider = "CartoDB.PositronNoLabels",
                   project = FALSE, 
                   crop = TRUE, 
                   zoom = 11)
```

Nous cr√©ons ensuite la carte avec `mapsf`.

```{r resto_map1}
#| results: hide
library(mapsf)
mf_theme(mar = c(0,0,0,0), inner = TRUE)
mf_export(x = tiles,
          filename = "fig/restaurants01.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, col = NA, lwd = 2, add = TRUE)
mf_map(resto, col = "red", add = TRUE)
mf_title("Les restaurants √† Qu√©bec")
mf_credits("¬© OpenStreetMap contributors ¬© CARTO", bg = "white")
dev.off()
```

![](fig/restaurants01.png)

Nous allons maintenant agr√©ger les restaurants dans une grille r√©guli√®re pour tenter rendre plus lisible l'organisation spatiale des restaurants √† Qu√©bec.

```{r grid}
#| results: hide
# Cr√©ation d'une grille r√©guli√®re (carreaux : 2km * 2km)
grid <- st_make_grid(target, cellsize = 2000)
grid <- st_sf(id = 1:length(grid), geom = grid)

# Comptage des points dans les polygones
grid$n <- lengths(st_intersects(grid, resto, sparse = TRUE))

# Cartographie
mf_export(x = tiles,
          filename = "fig/restaurants02.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, col = NA, lwd = 2, add = TRUE)
mf_map(x = grid[grid$n >0 , ], 
       var = "n", 
       type = "choro", 
       breaks = 'geom', 
       nbreak = 6, 
       alpha= .75, 
       border = NA, 
       pal = "Burg", 
       leg_frame = TRUE, 
       leg_pos = "left", 
       leg_title = "Nombre de restaurants",
       leg_val_rnd = 0,
       add = TRUE)
mf_title("Les restaurants √† Qu√©bec")
mf_credits("¬© OpenStreetMap contributors ¬© CARTO", bg = "white")
dev.off()
```

![](fig/restaurants02.png)

Nous pouvons aussi utiliser une m√©thode de lissage telle que la m√©thode de lissage par noyaux (KDE) gr√¢ce au package `spatstat` [@R-spatstat].

```{r kde}
#| results: hide
#| message: false
#| warning: false
library(spatstat)
library(terra)
library(tanaka)
p <- as.ppp(st_coordinates(resto), W = as.owin(st_bbox(target)))
# port√©e du lissage 500m
ds <- density.ppp(p, sigma = 500, eps = c(100, 100), positive = TRUE)
# transformation en raster terra et passage en unit√© par km¬≤
rasdens <- rast(ds) * 1000 * 1000
# ajout des information de projection
crs(rasdens) <- 'EPSG:3857'
# affichage par d√©faut
plot(rasdens)
```

Il est ensuite possible de repr√©senter les densit√©s calcul√©es avec les packages `tanaka` [@R-tanaka] et `mapsf`.
```{r kde2}
# Calcul des polygones de contour en fonction de bornes de classe
iso <- tanaka_contour(rasdens, breaks = c(1,2,5,10,20,25))
# choix d'une palette de couleur
cols <- mf_get_pal(n = 5, palette = "Teal", rev = TRUE)
# selection des r√©gion ou la densit√© est >= 1
iso <- iso[-1, ]
# Cartographie
mf_export(x = tiles,
          filename = "fig/restaurants03.png",
          width = ncol(tiles), height = nrow(tiles))
mf_raster(tiles, add = TRUE)
mf_map(target, add = T, col = NA, lwd = 2)
tanaka(iso, 
       legend.title = "Nombre de\nrestaurants\nau km¬≤\n(KDE, sigma=500)",
       legend.pos = "topright", 
       shift = 65,
       col = cols,
       add = TRUE)
mf_title("Les restaurants √† Qu√©bec")
mf_credits("¬© OpenStreetMap contributors ¬© CARTO",bg = "white")
dev.off()
```

![](fig/restaurants03.png)


## √Ä vous de jouer

- Vous devez √©tudier la r√©partition des restaurants dans une autre MRC, par exemple celle de Montr√©al. 

- Vous devez √©tudier la r√©partition des bars et pubs √† Qu√©bec (dans OpenStreetMap key = "amenity", value = "pub" et value = "bar"). 


Pour cela vous devrez construire un document quarto (au format de votre choix) et adapter quelques passage du code pr√©sent√© pr√©c√©demment. 











# Python


```{r reticulate-env}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```

```{python pandas-column-width-setup}
#| echo: false
import pandas as pd
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
```




## Le langage Python

:::: columns
::: {.column width="70%"}
- **Python** : un langage *polyvalent*, *interpr√©t√©* et *multi-paradigme*

- De plus en plus utilis√© pour la *science des donn√©es*

:::{.fragment}
- Un √©cosyst√®me robuste pour diff√©rents domaines d'application scientifiques

![](./fig/python-stack.png)
:::

:::

::: {.column width="30%"}
![](./fig/logo-python.png)

:::
::::

## √âcosyst√®me pour le g√©ospatial

## Donn√©es vectorielles

-   [**Bindings Python de GDAL/OGR**](https://gdal.org/api/python_bindings.html) [@GDAL]
-   [**Fiona**](https://fiona.readthedocs.io/en/stable/) [@fiona] - I/O (*wrapper* de haut niveau autour d'OGR)
-   [**Shapely**](https://shapely.readthedocs.io/)  [@sgillies_2023] - bindings Python de [GEOS](https://github.com/libgeos/geos) [@GEOS]
-   [**Pyproj**](https://pyproj4.github.io/pyproj) [@pyproj] - bindings Python de [PROJ](https://proj.org/) [@PROJ]
-   [**Geopandas**](https://geopandas.org/)  [@kelsey_jordahl_2020_3946761] - √âtend les `DataFrame`s de [pandas](https://pandas.pydata.org/) [@pandas]

![](./fig/logo-pandas.svg)

![](./fig/logo_geopandas.svg)

## Le package *GeoPandas*

Un projet open source pour faciliter le travail avec des donn√©es g√©ospatiales vectorielles en Python. GeoPandas √©tend Pandas pour permettre de disposer d'un type de colonne g√©om√©trique et pour permettre d'effectuer des op√©rations spatiales. Les op√©rations g√©om√©triques sont r√©alis√©es avec `shapely`, les acc√®s en lecture / √©criture aux fichiers utilisent `fiona` et la visualisation utilise `matplotlib`.

![Format des GeoDataFrame](./fig/geopandas-table.png)

- Utilisation :

::: {.panel-tabset .custom-tab}

### Import et lecture

```{python gpd-tuto-import-1}
#| echo: false
import geodatasets

file_path = geodatasets.get_path("nybb")
```

Avec la fonction `read_file` :

```{python gpd-tuto-import-2}
import geopandas as gpd

nybb = gpd.read_file(file_path)
```

### Affichage

Avec la m√©thode `plot` des `GeoDataFrame` :

```{python gpd-tuto-plot}
nybb.plot()
```

### SCR

Affichage :

```{python gpd-tuto-crs}
print(nybb.crs)
```

Transformation :

```{python gpd-tuto-transformation}
nybb_geo = nybb.to_crs('EPSG:4326')
```

### Affichage avec fond de carte

En utilisant la biblioth√®que `contextily` :

```{python gpd-tuto-contextily}
import contextily as cx

ax = nybb.to_crs('EPSG:3857').plot()
cx.add_basemap(ax, source='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png')
ax.set_axis_off()
ax
```

### Centroide

Simplement en utilisant l'attribut `centroid` des `GeoDataFrame` :

```{python gpd-tuto-centroid}
nybb.centroid.plot()
```

### Boundary

Simplement en utilisant l'attribut `boundary` des `GeoDataFrame` :

```{python gpd-tuto-boundary}
nybb.boundary.plot()
```

### Zone tampon

En utilisant la m√©thode `buffer` des `GeoDataFrame` :

```{python gpd-tuto-buffer}
buff_nybb = nybb.buffer(3000)
```

```{python gpd-tuto-buffer-2}
ax = buff_nybb.plot(color="red")
nybb.plot(ax=ax, color="aliceblue")
```


### Aggr√©gation

En utilisant la m√©thode `dissolve` des `GeoDataFrame` :

```{python gpd-tuto-agg}
# On peut utiliser dissolve(by="nom_colonne") si on veut aggr√©ger selon les valeurs d'une colonne
agg = nybb.dissolve()
agg.plot()
```


### Intersection

En utilisant la m√©thode `intersection` des `GeoDataFrame` :

```{python gpd-tuto-intersection}
from shapely import wkt

point = wkt.loads('Point(998769.1146889535 174169.7607268664)')

intersecting = nybb.intersection(point.buffer(35000))
```

<br>

```{python gpd-tuto-intersectiob-2}
ax = nybb.plot()
ax = intersecting.plot(ax=ax, color="red")
ax
```

:::

## Donn√©es raster

-   [**Rasterio**](https://rasterio.readthedocs.io/) [@gillies_2019] :
    * lecture / √©criture de raster (*wrapper* de haut niveau autour de GDAL)
    * donn√©es repr√©sent√©es sous forme d'`array` NumPy
    * reprojection
    * _resampling_
    * _virtual files_
    * etc.

-   [**Rasterstats**](https://pythonhosted.org/rasterstats/) :
    * r√©sumer des donn√©es raster sur la base de g√©om√©tries vectorielles
    * extraction de valeurs √† un point pr√©cis

-   [**xarray**](https://docs.xarray.dev/en/stable/) [@xarray] et [**rioxarray**](https://corteva.github.io/rioxarray/) [@rioxarray]:
    * *xarray* pour travailler avec des tableaux multidimensionnels √©tiquet√©s
    * *rioxarray* pour ouvrir des jeux des donn√©es raster avec *rasterio*, les stocker dans le format de *xarray*, et avoir acc√®s √† diff√©rentes fonctionnalit√©s de *rasterio*
    * moins "rustique" que d'utiliser rasterio seul / d√©pend de l'usage souhait√©

## Le package *Rasterio*

Exemple d'utilisation :

```{python example-rio-1}
import rasterio as rio

with rio.open('./data/MODIS_ARRAY.nc') as f:
    # M√©tadonn√©es :
    metadata = f.meta
    # Lire toutes les bandes :
    data = f.read()
    # Ou f.read(1) pour lire seulement la premi√®re bande
```

- Un dictionnaire de m√©ta-donn√©es + un tableau NumPy contenant la (ou les) bande(s) :

```{python example-rio-2}
print(metadata)
print(data)
```

## Les package *xarray* et *rioxarray*

Exemple d'utilisation :

::: {.panel-tabset .custom-tab}

### Import et lecture

```{python xarray-tuto-import-1}
import rioxarray
import xarray

xds = xarray.open_dataarray("./data/MODIS_ARRAY.nc")
```

- Un objet de type `xarray.DataArray` ou `xarray.Dataset` qui contient les diff√©rentes m√©ta-donn√©es et les donn√©es :

```{python xarray-tuto-import-2}
xds
```

### Compl√©tion des valeurs manquantes

```{python xarray-tuto-na}
filled = xds.rio.interpolate_na()
```

### Affichage

En utilisant la m√©thode `plot` des objets `xarray.DataArray` (ici apr√®s avoir s√©lections un *subset* des donn√©es) :

```{python xarray-tuto-plot}
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(15, 5))
ax1, ax2 = (fig.add_subplot(131), fig.add_subplot(133))

xds.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax1)
filled.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax2)
```

### SCR

- Affichage :

```{python xarray-tuto-crs-1}
xds.rio.crs
```

- Transformation :

```{python xarray-tuto-crs-2}
xds = xds.rio.reproject("EPSG:6623")
```

### D√©coupage

- D√©coupage selon l'emprise des donn√©es contenues dans un `GeoDataFrame` (ici `gdf`) :

```{python xarray-tuto-clipping}
#| eval: false
clipped = xds.rio.clip(gdf.geometry.values, gdf.crs, drop=False, invert=True)
```

:::


## Analyse spatiale

:::: {.columns}

::: {.column width="80%"}

√âcosyst√®me de biblioth√®ques pour l'analyse spatiale [PySAL](https://pysal.org/) (Python Spatial Analysis Library, @pysal2007) :

- **Explorer**:
  - Analyse exploratoire des donn√©es spatiales (package [esda](https://pysal.org/esda/))
  - Analyse de la dynamique des donn√©es spatiales longitudinales (package [giddy](https://pysal.org/giddy/))
  - Mesure des in√©galit√©s dans l'espace et dans le temps (package [inequality](https://inequality.readthedocs.io/en/latest/))
  - Analyse statistique de motifs ponctuels planaires (package [pointpats](https://pysal.org/pointpats/))
  - Mesure de la s√©gr√©gation dans le temps et dans l'espace (package [segregation](https://pysal.org/segregation/))
  - Morphom√©trie urbaine (package [momepy](https://docs.momepy.org/en/stable/))

- **Mod√©liser**:
  - R√©gression g√©ographiquement pond√©r√©e √† plusieurs √©chelles (package [mgwr](https://mgwr.readthedocs.io/en/latest/))
  - Mod√®les lin√©aires g√©n√©ralis√©s √©pars (package [spglm](https://spglm.readthedocs.io/en/latest/))
  - Mod√®les d'interaction spatiale (package [spint](https://spint.readthedocs.io/en/latest/))
  - Mod√®les de r√©gression spatiale (package [spreg](https://spreg.readthedocs.io/en/latest/))
  - Mod√®les de composantes de variance √† corr√©lation spatiale √† plusieurs niveaux (package [spvcm](https://github.com/pysal/spvcm))
  - *Areal interpolation* et cartographie dasym√©trique (package [tobler](https://pysal.org/tobler/))
  - Accessibilit√© spatiale (package [access](https://pysal.org/access/))
  - Optimisation spatiale (package [spopt](https://pysal.org/spopt/))

:::

::: {.column width="20%"}

![](./fig/logo-pysal.png)
:::

::::


## Autres packages utiles ...

-   Binding Python pour [GRASS](https://grass.osgeo.org/grass82/manuals/libpython/index.html) + Int√©gration dans les notebooks Jupyter

![Source: <https://grass.osgeo.org/news/2022_06_05_results_student_grant_caitlin/>](./fig/grass_jupyter_combo_vis.png)

- [Iris](https://scitools-iris.readthedocs.io/en/stable/)

- Pour la cartographie : [cartopy](https://scitools.org.uk/cartopy/docs/latest/) ; [geoviews](https://geoviews.org/) et [geoplot](https://residentmario.github.io/geoplot/) bas√©s sur *cartopy* ; [PyGMT](https://www.pygmt.org/latest/) (selon les usages - pas de solution aussi aboutie que `mapsf` pour les cartes r√©alis√©es en SHS).

![](./fig/cartopy.png)

## Ressources Python G√©ospatial

- [https://py.geocompx.org/](https://py.geocompx.org/) [@Dorman2022]

- [https://geo-python-site.readthedocs.io/en/latest/](https://geo-python-site.readthedocs.io/en/latest/)

- [https://automating-gis-processes.github.io](https://automating-gis-processes.github.io)

- [https://www.earthdatascience.org/courses/use-data-open-source-python/](https://www.earthdatascience.org/courses/use-data-open-source-python/)

- [https://geographicdata.science/book/intro.html](https://geographicdata.science/book/intro.html)


## Interaction R ‚áÑ Python dans Quarto

::: {.panel-tabset}

### R ‚Üí Python

- D√©finition de variables dans un chunk R :

```{r example-r-1}
a <- 42
b <- list(1, 2, 3)
c <- c(12, 13, 14)
```

- R√©cup√©ration depuis un chunk Python :

*en utilisant la variable `r`, un point, et le nom de la variable R √† r√©cup√©rer*

```{python example-python-1}
print(r.a)
print(r.b)
print(r.c)
```


### Python ‚Üí R

- D√©finition de variables dans un chunk Python :

```{python example-python-2}
a = 42
b = [1, 2, 3]
```

- R√©cup√©ration depuis un chunk R :

*en utilisant la variable `py`, un dollar `$`, et le nom de la variable Python √† r√©cup√©rer*

```{r example-r-2}
print(py$a)
print(py$b)
```


:::

## Interaction R ‚áÑ Python dans Quarto (suite)

- Il est possible d'√©changer des types plus complexes (`data.frame` ‚áÑ `DataFrame` pandas, tableau numpy, etc.)


::: {.panel-tabset}

### R ‚Üí Python

- Depuis un chunk R :

```{r example-r-3}
df <- data.frame(
   emp_id = c(1:5),
   emp_name = c("Rick","Dan","Michelle","Ryan","Jane"),
   salary = c(623.3,515.2,611.0,729.0,843.25),
   start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27")),
   stringsAsFactors = FALSE
)
```

- R√©cup√©ration depuis un chunk Python :

```{python example-python-3}
df = r.df
print(df.head())
```


### Python ‚Üí R

- Depuis un chunk Python :

```{python example-python-4}
import pandas as pd
import numpy as np

df2 = pd.DataFrame({
  "emp_id": list(range(5)),
  "emp_name": ["Rick", "Dan", "Michelle", "Ryan", "Jane"],
  "salary": [623.3, 515.2, 611.0, 729.0, 843.25],
  "start_date": pd.to_datetime(["2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27"]),
})

arr = np.array([[12, 47], [34, 90], [23, 19]])
```

- Utilisation depuis un chunk R :

```{r example-r-4}
head(py$df2)
print(py$arr)
```

:::

## Interaction R ‚áÑ Python dans Quarto (suite)

Et pour les objets spatiaux ? (*sf* / *geopandas*)

- Si la conversion `data.frame` ‚áÑ `DataFrame` est transparente, il n'en est pas de m√™me pour les dataframe avec une composante spatiale (perte de la dimension spatiale / colonne `geometry` contient d√©sormais ...)

- L'√©criture d'une petite function permet de r√©soudre √ßa :

```{r import-py}
#| message: false
#| echo: false
#| eval: false
# Import des donn√©es
library(sf)
mun_raw <- st_read("geom/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("geom/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
crs <- "EPSG:6623"
mun <- st_transform(mun_raw, crs)
mrc <- st_transform(mrc_raw, crs)
# Cr√©ation d'une couche des r√©gions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
resto_raw <- st_read('geom/resto.geojson', quiet = TRUE)
resto <- st_transform(resto_raw, crs)

sel <- "Qu√©bec"
```

```{python sf-gpd-conversion-function}
from shapely.geometry import shape
import geopandas as gpd

def restore_geodataframe(df, crs, geom_type):
  geom = df.geometry.apply(lambda coords: shape({ "type": geom_type, "coordinates": coords }))
  gdf = gpd.GeoDataFrame(df.drop(['geometry'], axis=1), geometry=geom)
  gdf.set_crs(crs, inplace=True)
  return gdf
```


Ainsi, les objets `sf` pourront √™tre convertis en `GeoDataFrame` ainsi :

```{python sf-gpd-conversion-1}
mrc = restore_geodataframe(r.mrc, r.epsg_6623, "MultiPolygon")
mrc.head()
```

## Python, Quarto et interactivit√©

- Utilisation des widgets Jupyter possible (seulement is utilisation de l'engin de rendu `jupyter`, pas avec `knitr` - i.e. l'inverse des *htmlwidgets* en R qui ne fonctionne que si `knitr` est utilis√©)

- Exemple :

![](./fig/example-quarto-jupyter-widgets.jpg)

- Documentation : [https://quarto.org/docs/interactive/widgets/jupyter.html](https://quarto.org/docs/interactive/widgets/jupyter.html)

## Exemples d'analyse sur les donn√©es du Qu√©bec

-   Les imports n√©cessaires :

```{python demo-import}
import numpy as np
import rasterio as rio
import pandas as pd
import geopandas as gpd
import rioxarray
import xarray

from rasterio.warp import calculate_default_transform, reproject, Resampling
from matplotlib import pyplot as plt
from rasterio.plot import show
from rasterio.mask import mask
from rasterstats import zonal_stats, point_query
```

-   On r√©cup√®re les jeux de donn√©es et quelques autres infos (SRC, etc.) depuis l'environnement R :

```{python demo-vector-dataset-opening}
# Le SCR des donn√©es
dst_crs = r.epsg_6623

# On r√©cup√®re le jeu de donn√©es "mrc" (municipalit√©s r√©gionales de comt√©)
# et le jeu de donn√©es "resto"
mrc = restore_geodataframe(r.mrc, dst_crs, "MultiPolygon")
resto = restore_geodataframe(r.resto, "EPSG:3857", "Point")
resto.to_crs(dst_crs, inplace=True)
reg = mrc.dissolve(by="MUS_NM_REG")

sel = r.nom_mrc # Qu√©bec

# Chemin du jeu de donn√©es raster
# et du fichier contenant les descriptions des cat√©gories
lc_fp = './data/T01_PROVINCE.tif'
lc_categories_fp = './data/correspondance_raster_CL_COUV.dbf'
```

-   On extrait les entit√©s correspondantes et on les affiche, relativement au reste de la province :

```{python demo-first-plot}
extract = mrc[mrc.MUS_NM_MRC == sel]

ax = mrc.plot(color="lightblue", edgecolor="grey", alpha=0.5, figsize=(16, 12))
ax = reg.plot(ax=ax, color=None, edgecolor="orange", alpha=0.8)
ax = extract.plot(ax=ax, color="red")
ax.set_axis_off()
ax
```

-   Ouverture et reprojection d'un jeu de donn√©es raster (avec *rioxarray*) :

```{python demo-open-raster}
xds = rioxarray.open_rasterio(lc_fp)
xds = xds.rio.reproject(dst_crs)
xds
```

- Affichons le raster reprojet√© et l'emprise de la ville de Qu√©bec :

```{python demo-plot-raster}
# Remplacer les '255' par '0'
xds.data[xds.data == 255] = 0

# √âtendue des donn√©es
bounds = xds.rio.bounds()
extent = [bounds[0], bounds[2], bounds[1], bounds[3]]

# Cr√©ation d'une figure vide
fig, ax = plt.subplots(figsize=(16, 12))
# Affichage du raster (attribut 'data' de l'objet xds)
show(xds.data[0], ax=ax, extent=extent, cmap="Set3")
# Affichage de la ville de Qu√©bec en rouge par dessus
extract.plot(ax=ax, color='red', edgecolor='red', linewidth=2)
# On enl√®ve l'affichage des axes
ax.set_axis_off()
ax
```

- Ouverture du fichier DBF qui contient les correspondances entre les codes et les noms des cat√©gories d'utilisation des sols

```{python demo-open-dbf}
categories = pd.DataFrame(
  gpd.read_file(lc_categories_fp, encoding='utf-8')[['ID', 'CL_COUV', 'Descriptio']])
categories.head(11)
```

<br>

```{python demo-categories-mapping}
# On va convertir cette DataFrame en un dictionnaire pour l'utiliser
# comme un mapping ID -> Description
categories = {
  int(k): v['Descriptio']
  for k,v in categories[['ID', 'Descriptio']].set_index('ID').to_dict(orient='index').items()
}
# Bien qu'il y ait une cat√©gorie 'Pas de donn√©es' (ID 10)
# certaines cellules ne comportent pas de valeur (nodata, ici avec la valeur 0)
categories[0] = 'Pas de donn√©es'
categories
```

-   Calculer les statistiques zonales (combien de cellules de chaque type dans la s√©lection) :

```{python demo-zonal-stats}
stats = zonal_stats(extract, xds.data[0], affine=xds.rio.transform(), categorical=True, nodata=0)
stats
```

-   Tra√ßons un histogramme de ce r√©sultat, en utilisant les noms appropri√©s des cat√©gories d'utilisation des sols :

```{python demo-plot-zonal-stats}
#| output-location: slide
# Trier les valeurs par le nombre de cellule
sorted_values = sorted(stats[0].items(), key = lambda x: x[1], reverse=True)

# Utilise les noms de cat√©gories du DataFrame `categories`...
x = [categories[int(k)] for k, _ in sorted_values]

# ...et les valeurs que nous venons de calculer avec la fonction `zonal_stats`
height = [v for _, v in sorted_values]

fig, ax = plt.subplots(figsize=(8, 8))
bar_container = ax.bar(x, height)
ax.set_xticklabels(
    ax.get_xticklabels(),
    rotation=45,
    horizontalalignment='right'
)
fig.tight_layout()
ax
```

- Dans quel type d'occupation du sol se trouvent les restaurants pr√©c√©demment r√©cup√©r√©s ?

```{python demo-resto-point-query}
geoms = resto['geometry'].tolist()

resto["lc"] = [categories[int(x)] for x in point_query(vectors=geoms, raster=xds.data[0], nodata=0, affine=xds.rio.transform())]
resto.head()
```

- Quels restaurants ne sont pas situ√©s dans une zone artificialis√©e ?

```{python demo-resto-selection-1}
selection = resto[(resto.lc != 'Surfaces artificielles') & (resto.lc != 'Pas de donn√©es')]
selection
```


```{python demo-resto-selection-plot}
ax = extract.plot(color=None, edgecolor="black")
ax = selection.plot(ax=ax, marker='x', color='red', markersize=8)
ax.set_axis_off()
ax
```

## √Ä vous de jouer üöÄ

**Objectif** : Comparez l'occupation du sol de la MRC de Trois-Rivi√®res √† l'occupation du sol de la MRC de Montr√©al.

- Vous cherchez √† obtenir :
    - un diagramme en barre (combinant le r√©sultat des statistiques zonales pour la MRC de Trois-Rivi√®res et pour la MRC de Montr√©al)
    - un r√©sum√© (pourquoi pas en HTML !) de la surface de chaque type d'occupation du sol, comme celui pr√©sent√© en exemple ci-dessous, pour Trois-Rivi√®res et Montr√©al

![Exemple de tableau de r√©sum√©](./fig/summary-lc.png)

- Au d√©but de votre document, vous devez ins√©rer un chunk de code `R` pour pr√©ciser la localisation de votre environnement virtuel Python - comme nous utilisons `knitr`, c'est ce qui va permettre √† `reticulate` de savoir o√π chercher les packages Python qui ont √©t√© install√©s pour cet atelier :

````
```{{r}}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```
````

**_Besoin d'aide ?_**

::: {.callout-tip icon=false collapse="true"}
### Quelle suite d'action r√©aliser ?

- Cr√©er un chunk 'r' pour dfinir la localisation de l'environnement virtuel
- Cr√©er les chunks 'python' correspondants aux actions suivantes :
    - Ouvrir le jeu de donn√©es raster
    - Ouvrir le jeu de donn√©es vecteur
    - S'assurer qu'ils sont dans le m√™me syst√®me de coordonn√©es de r√©f√©rence et effectuer la transformation si ce n'est pas le cas
    - Obtenir les statistiques zonales pour la MRC de Trois-Rivi√®res
    - Obtenir les statistiques zonales pour la MRC de Montr√©al
    - Produire le diagramme et le tableau synth√©tisant ces informations

:::

::: {.callout-tip icon=false collapse="true"}
### De quelles biblioth√®ques a-t-on besoin ?


```{python help-import}
#| eval: false
import rioxarray
import xarray
import pandas as pd
import geopandas as gpd
import rasterstats
import matplotlib.pyplot as plt
```

:::

::: {.callout-tip icon=false collapse="true"}
### Besoin d'aide pour ouvrir les donn√©es raster ?


```{python help-xarray-opening}
#| eval: false
xds = xarray.open_dataarray("/chemin/vers/le/fichier")
```

:::

::: {.callout-tip icon=false collapse="true"}
### Besoin d'aide pour ouvrir les donn√©es vecteur ?


```{python help-gpd-opening}
#| eval: false
gdf = gpd.read_file('/chemin/vers/le/fichier')
```

:::

::: {.callout-tip icon=false collapse="true"}
### Comment connaitre la taille d'une cellule raster ?

En utilisant les param√®tres d√©crivant la matrice de transformation de g√©or√©f√©rencement du jeu de donn√©es raster en question (cette transformation fait correspondre les coordonn√©es ligne/colonne des pixels aux coordonn√©es du syst√®me de r√©f√©rence de l'ensemble de donn√©es) :

```{python help-xarray-transform}
#| eval: false
transform = xds.rio.transform()
```

Puis en utilisant la premi√®re et la cinqui√®me valeur qui repr√©sentent respectivement la largeur et la hauteur du pixel :

```{python help-xarray-pixel-size}
#| eval: false
area_pixel = transform[0] * abs(transform[4]) # la hauteur est g√©n√©ralement n√©gative
```

:::

::: {.callout-tip icon=false collapse="true"}
### Comment faire pour qu'un *chunk* retourne du HTML ?

Par exemple en stockant du Markdown dans une cha√Æne de caract√®re et en le transformant en HTML avec `IPython.display.Markdown` :

```{python help-ipython-markdown}
#| eval: false
from IPython.display import Markdown

rendu = '''
## R√©sum√©

| Cat√©gorie | Superficie |
|---------|----------|
| Aahah | 21.34 |
'''

Markdown(rendu)
```

:::



# Observable JavaScript

![](fig/js.png){width="30%"}

## Qu'est-ce que l'ojs ?

L'<b>Observable javascript {ojs}</b> est un ensemble d'am√©liorations apport√©es √† vanilla JavaScript cr√©√© par Mike Bostock (√©galement auteur de D3 [@D3]). Observable JS se distingue par son ex√©cution r√©active, qui convient particuli√®rement bien √† l'exploration et √† l'analyse interactives des donn√©es. 

![](fig/d3.png){width="20%"} ![](fig/arrow.png){width="20%"} ![](fig/observable.png){width="20%"} <br/> **Observable** est aussi une startup fond√©e par Mike Bostock et Melody Meckfessel, qui propose une plateforme 100% en ligne (<https://observablehq.com>) pour concevoir, partager et diffuser des visualisations de donn√©es.

![](fig/frise.png)

**Observable** c'est donc aussi C'est aussi une [plateforme web](https://observablehq.com/) qui h√©berge des notebooks computationnels sur la visualisation de donn√©es.

![](fig/notebookobs.png)

**Objectifs**

üëâ Construire un langage et un √©cosyst√®me d√©di√© √† la visualisation de donn√©es sur le web

üëâ F√©d√©rer et faire collaborer une communaut√©

## Observable dans Quarto

Le runtime d'Observable est Open Source et est utilis√© dans Quarto.

Dans Quarto, toutes les instructions s'√©crivent dans des chunks {ojs}

``` {{ojs}}
```

On peut param√©trer l'affiche et/ou l'execution du code avec **//\| echo** et **//\| eval**.

``` {{ojs}}
//| echo: false
//| eval: true
```

*NB : Contrairement aux chunks R et Python, le code s'execute just in time dans le navigateur web une fois le notebook g√©n√©r√©. Seul l'export html est donc pris en compte.*

## Principes

Le langage JavaScript n'a pas du √©t√© con√ßu pour l'analyse de donn√©es. Mais, gros point fort, on a tous un navigateur web et JavaScript tourne sur toutes les machines. Le but : b√¢tir une √©volution du langage JavaScript pour en faire un langage adapt√© √† l'analyse et la visualisation de donn√©es sur le web.

l'ojs ressemble donc √† du JavaScript, mais il y a quelques diff√©rences.

### üëâ Des biblioth√®ques pr√©charg√©es üìä

OJS c'est du JavaScript + plein de biblioth√®ques pr√© charg√©es : <br/>

| Symbol   | Name              | Version            |
|----------|-------------------|--------------------|
| \_       | Lodash            | 4.17.21            |
| aq       | Arquero           | \${aq.version}     |
| Arrow    | Apache Arrow      | 4.0.1              |
| d3       | D3.js             | \${d3.version}     |
| dot      | Graphviz          | 0.2.1              |
| htl      | Hypertext Literal | \${htl.version}    |
| Inputs   | Observable Inputs | \${Inputs.version} |
| L        | Leaflet           | \${L.version}      |
| mermaid  | Mermaid           | 9.1.6              |
| Plot     | Observable Plot   | \${Plot.version}   |
| SQLite   | SQL.js            | 1.7.0              |
| topojson | TopoJSON Client   | 3.1.0              |
| vl       | Vega, Vega-Lite   | 5.22.1, 5.2.0      |

### üëâ Des cellules üôã

Chaque d√©but de ligne identifie une cellule ojs. Chaque ligne d√©finit une variable et une cellule qui doit √™tre unique sur l'ensemble du document.

En d√©but de cellule, on n'utilisera pas les d√©clarations de variables avec **let**, **const** ou **var**.

``` {{ojs}}
a = 10 // une cellule
b = 20 // une cellule
```

``` {{ojs}}
c = a + b // une cellule
```

A l'int√©rieur d'un bloc de code, on √©crit du vanilla JavaScript.

``` {{ojs}}
d = { 
  let a = 10 
  let b = 30
  return a + b 
} // Une cellule
```

### üëâ Des promesses sont r√©solues ‚úÖ

Dons ojs, les promesses sont r√©solues d'une cellule √† l'autre. Cela permet d'enlever de la complexit√© li√©e √† la conception asynchrone du JavaCript. Ca va √™tre tr√®s ptratique quand on charge un jeu de donn√©es par exemple. 

### üëâ L'ordre des cellules n'a pas d'importance ü§Ø

On peut donc √©crire √ßa

``` {{ojs}}
result = val1 * val2
```

avant √ßa

``` {{ojs}}
val1 = 10
val2 = 20
```

Le lien entre les cellules se fait de fa√ßon topologique et non de haut en bas.

![](fig/topology.png)

### üëâ Tout est r√©actif üî•

D√®s lors qu'une cellule est modifi√©e, les cellules qui en d√©pendent sont modifi√©es √©galement.

Pour modifier la valeur d'une cellule, on utilise des **`Inputs`** (des composants propos√©s par OJS pour explorer les donn√©es) avec le mot cl√© [**`viewof`**](https://observablehq.com/@observablehq/inputs)

```{ojs}
viewof x = Inputs.range([0, 255], {step: 1})
```

```{ojs}
viewof y = Inputs.text({value: 30})
```

```{ojs}
viewof z = Inputs.radio([10, 100, 1000], {value: 10})
```

```{ojs}
x * y * z
```

Ce syst√®me est pratique pour modifier des visualisations de donn√©es.

Ici, un exemple avec un simple cercle dessin√© en svg.

```{ojs}
viewof color = Inputs.color({ label: "Couleur", value: "#4ab58c" })
viewof radius = Inputs.range([1, 50], { label: "Rayon", step: 1, value: 100 })
viewof position = Inputs.range([50, 950], { label: "Position", step: 1, value: 50 })
```

```{ojs}
html`<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">
  <circle cx=${position} cy="50" r=${radius} fill="${color}"/>
</svg>`
```

## L'√©cosyst√®me spatial de l'ojs

L'√©cosyst√®me spatial de JavaScript est moins √©toff√© que ce qu'on peut trouver en Python ou en R. Mais on trouve quand m√™me des choses int√©ressantes qui permettent de faire de la g√©omatique directement dans le navigateur web. Voici quelques exemples.

**Les fonctionnalit√©s spatiales de `d3.js`**

::: columns
::: {.column width="8%"}
![](fig/d3.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`d3-geo`**](https://github.com/d3/d3-geo) est le module spatial de D3. Il permet de g√©rer les projections cartographiques, les formes sph√©riques et la trigonom√©trie sph√©rique. Voir aussi [**`d3-geo-projection`**](https://github.com/d3/d3-geo-projection). [**`d3-delaunay`**](https://github.com/d3/d3-delaunay) est une biblioth√®que rapide pour calculer le diagramme de Vorono√Ø d'un ensemble de points bidimensionnels. Elle est bas√©e sur Delaunator, une biblioth√®que rapide pour calculer la triangulation de Delaunay en utilisant des algorithmes de balayage. Le diagramme de Vorono√Ø est construit en reliant les circonf√©rences des triangles adjacents dans la triangulation de Delaunay. [**`d3-geo-voronoi`**](https://github.com/Fil/d3-geo-voronoi) est une adaptation de d3-delaunay sur la sph√®re.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/topojson.svg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`TopoJSON`**](https://github.com/topojson/topojson) est une extension de GeoJSON. La librairie permet de r√©aliser des op√©rations SIG bas√©es sur la topologie (agr√©gation, voisins, simplification, etc.)
:::
:::

**Les biblioth√®ques SIG**

::: columns
::: {.column width="8%"}
![](fig/turf.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`turf`**](https://turfjs.org/) est une biblioth√®que JavaScript pour l'analyse spatiale (de type SIG). Elle comprend les op√©rations spatiales traditionnelles, des fonctions d'aide pour la cr√©ation de donn√©es GeoJSON, ainsi que des outils de classification des donn√©es et de statistiques. L'avantage de turf est d'√™tre modulaire. On ne charge que ce dont on a besoin.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/spljs.jpg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`spl.js`**](https://turfjs.org/) est une impl√©mentation de SpatiaLite (et de ses amis : sqlite, geos, proj, rttopo) pour le navigateur.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/geotoolbox.svg)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`geotoolbox`**](https://github.com/neocarto/geotoolbox) est un outil javascript pour les g√©ographes bas√© sur d3geo, topojson et jsts. Il permet de traiter simplement les propri√©t√©s geojson et fournit plusieurs op√©rations SIG utiles pour la cartographie th√©matique.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/gdal.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`Gdals3.js`**](https://github.com/bugra9/gdal3.js) est un portage des applications Gdal (gdal_translate, ogr2ogr, gdal_rasterize, gdalwarp, gdaltransform) vers Webassembly. Il permet de convertir des donn√©es g√©ospatiales matricielles et vectorielles dans divers formats et syst√®mes de coordonn√©es.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/proj4.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`proj4js`**](http://proj4js.org/) est une biblioth√®que JavaScript permettant de transformer les coordonn√©es d'un syst√®me de coordonn√©es √† un autre, y compris les transformations de datum
:::
:::

**Dataviz / cartographie**

::: columns
::: {.column width="8%"}
![](fig/plot.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`plot`**](https://observablehq.com/plot/) est la biblioth√®que de visualisation de donn√©e d√©velopp√©e par Observable (Mike Bostock et Philippe Rivi√®re). Au d√©part pens√©e pour la visualisation de donn√©es statistiques, elle permet aujourd'hui de r√©aliser des cartes. Plot est disponible par d√©faut dans les cellules {ojs}.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/vega.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`vega-lite`**](https://github.com/vega/vega-lite) est un outil de visualisation mettant en ≈ìuvre une grammaire graphique, similaire √† ggplot2. Cette biblioth√®que est disponible par d√©faut dans les cellules {ojs}.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/bertin.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`bertin`**](https://github.com/neocarto/bertin) est une biblioth√®que √©crite en JavaScript qui permet de r√©aliser des cartes th√©matiques pour le web. Sa conception vise √† permettre aux utilisateurs de cr√©er rapidement des cartes th√©matiques interactives sans forcement conna√Ætre le langage JavaScript.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/gridviz.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`Gridviz`**](https://github.com/eurostat/gridviz) est une biblioth√®que JavaScript bas√©e sur WebGL d√©velopp√©e par Julien Gaffuri et Joe Davies. Elle permet de visualiser des donn√©es carroy√©es (ou tout ensemble de donn√©es tabulaires avec une position x/y) dans le navigateur dans une grande vari√©t√© de styles cartographiques.
:::
:::

::: columns
::: {.column width="8%"}
![](fig/logo-go-cart-wasm.png)
:::

::: {.column width="2%"}
:::

::: {.column width="90%"}
[**`go-cart-wasm`**](https://github.com/riatelab/go-cart-wasm) est une biblioth√®que JS/WASM permettant de r√©aliser des cartogrammes bas√©s sur le flux (comme d√©crit dans "Gastner, Seguy, and More (2018).
:::
:::

## Importer des donn√©es

Pour importer des donn√©es en **`{ojs}`**, on utilise l'instruction **`FileAttachment()`**

Pour un fichier JSON

``` js
mrc = FileAttachment("data/mrc.geojson").json()
munic = FileAttachment("data/munic.geojson").json()
```

Pour un fichier csv

``` js
FileAttachment("data.csv").csv({typed: true})
```
On peut aussi r√©cup√©rer des donn√©es depuis R ou Python avec l'instruction [**`ojs_define`**](https://neocarto.github.io/docs/notebooks/ojsdefine/)

::: {.callout-tip}
## NB
*Souvenez vous que le code JavaScript s'execute dans le navigateur web. Il s'execute donc apr√®s le code R et Python.*
:::

`ojs_define` fonctionne bien pour des simples variables ou des data frames. Mais ne renvoie pas un geoJSON correctement format√© √† partir d'un spatial dataframe.

*chunck r*

```{r}
ojs_define(test = mun)
```

*Chuck ojs*

```{ojs}
test
```

Une solution consiste √† utiliser le package `geojsonsf.`

*Chunck r*

```{r}
library("geojsonsf")
ojs_define(mun = sf_geojson(st_transform(mun, 4326)))
```

`mun` existe desormais dans l'univers ojs et est correctement format√©. Mais c'est une chaine de caractere. On utilisera donc `JSON.parse` pour l'utiliser

*Chunk ojs*

```{ojs}
JSON.parse(mun)
```

```{ojs}
//| eval: true
//| echo: false
tmp = FileAttachment("data/munic.geojson").json()
munic =  geo.rewind(geo.simplify(tmp, {k:0.1}))
tmp2 = FileAttachment("data/mrc.geojson").json()
mrc =  geo.rewind(geo.simplify(tmp2, {k:0.1}))

```

## Visualiser les donn√©es statistiques

Pour regarder la table attributaire, on utilise **`Inputs.table()`**

```{ojs}
Inputs.table(munic.features.map(d => d.properties))
```

Avec **`{ojs}`**, on va aussi pouvoir faire des graphiques avec la biblioth√®que **`plot`**. Pour cela, on fait quelques manipulations de donn√©es.

Tout d'abord, on r√©cup√®re les noms des 20 communes les plus peupl√©es, class√©es par ordre d√©croissant de population.

```{ojs}
communes = munic.features
  .map((d) => d.properties)
  .sort((a, b) => d3.descending(a.POP_2022, b.POP_2022))
  .map((d) => d.MUS_NM_MUN)
  .slice(0, 20)
```

```{ojs}
//| echo: false
//| eval: true
communes
```

On met en forme les donn√©es.

```{ojs}
data = {
  let arr = [];
  communes.forEach((d) => {
    let tmp = munic.features
      .map((d) => d.properties)
      .find((x) => x.MUS_NM_MUN == d);
    for (let i = 2001; i <= 2022; i++) {
      arr.push({ year: i, pop: tmp["POP_" + i], com: d });
    }
  });
  return arr;
}
```

```{ojs}
//| echo: false
//| eval: true
Inputs.table(data, {width:250, height:250})
```

Puis on r√©alise le graphique avec `Plot` en proposant de s√©lectionner une commune.

::: {.callout-tip}
## NB
*Plot est directement disponible dans {ojs}. Mais si on souhaite une autre version, on peut l'appeler.*
```{ojs}
Plot = require("@observablehq/plot@0.6.7")
```
*La version 0.6.7 impl√©mente les infobulles.*
:::





```{ojs}
viewof commune = Inputs.select(communes, { label: "Commune" })
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population (${commune})`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data.filter(d => d.com == commune), {
      x: "year",
      y: "pop",
      stroke: "red",
      strokeWidth: 2
    })
  ]
})
```

On peut √©galement mettre toutes les courbes sur un graphique

```{ojs}
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data, {
      x: "year",
      y: "pop",
      stroke: "com",
      strokeWidth: 2,
      tip: true
    })
  ]
})
```

Ou en normalisant

```{ojs}
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population`
  },
  marginLeft: 60,
  marks: [
    Plot.lineY(data, Plot.normalizeY("first",{
      x: "year",
      y: "pop",
      stroke: "com",
      strokeWidth: 2,
      tip: true
    }))
  ]
})
```

## Visualiser les g√©om√©tries

Comme leaflet [@Leaflet] est disponible dans les cellules {ojs}, on peut directement afficher les g√©om√©tries.

```{ojs}
{
  const container = yield htl.html`<div style="height: 500px;">`;
  const map = L.map(container);
  const layer = L.geoJSON(mrc).addTo(map);
  map.fitBounds(layer.getBounds(), { maxZoom: 9 });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution:
      "¬© <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors"
  }).addTo(map);
}
```

On peut √©galement afficher la carte simplement avec la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin).

```{ojs}
bertin = require("bertin")
```

```{ojs}
bertin.quickdraw(mrc)
```

## Un peu de SIG

La bibioth√®que **`geotoolbox`** permet de faire facilement differentes operations SIG.

```{ojs}
geo = require("geotoolbox")
```

-   **Simplification**

```{ojs}
viewof simpl = Inputs.range([0.0001, 0.2], { label: "Simplification",  value: 0.1 })
mrc2 = geo.simplify(mrc, { k: simpl })
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: munic},layers:[{geojson: mrc2, stroke:"black", strokeWidth:1.5, fill:"white", rewind: true}]})
```

-   **Centroid**

```{ojs}
ctr = geo.centroid(mrc)
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: mrc}, layers:[{geojson: ctr, fill:"red"},{geojson: mrc, fill:"#CCC"}, ]}) 
```

-   **Buffer**

```{ojs}
quebec = geo.filter(mrc, (d) => d.MUS_CO_MRC == "23")
buff = geo.buffer(quebec, { dist: distance})
ctr2 = geo.clip(ctr, {clip: buff})
```

```{ojs}
//| echo: false
viewof distance = Inputs.range([0, 500], {
  label: "Distance",
  value: 300,
  step: 10
})
bertin.draw({layers:[{geojson: quebec, fill:"red"}, {geojson: ctr2, fill:"red"}, {geojson: buff, stroke:"red", fill: "none", strokeWidth:2},{geojson: mrc, fill:"#CCC"}, ]}) 
```

## Cartographie th√©matique

Pour cr√©er des cartes th√©matiques, on peut utiliser la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin) [@bertinS].

La fonction **`draw`** permet de r√©aliser n'importe quel type de carte.

![](fig/bertin_code.png)

Par d√©faut, la couche s'affiche simplement.

```{ojs}
bertin.draw({layers:[{geojson: munic, fill: "#d18de0"}]})
```

On peut ajouter l'attrubut **`tooltip`** pour afficher des infobulles.

```{ojs}
bertin.draw({
  layers:[
    { 
      geojson: munic, fill: "#d18de0",
      tooltip: "$MUS_NM_MUN"
    }
  ]
})
```

**Cartographie th√©matique**

A pr√©sent, r√©alisons une carte de la population en 2022. Pour cela, on utilise le type **`bubble`**.

Par d√©faut, √ßa donne ceci :

```{ojs}
bertin.draw({
    layers: [
      {
        type: "bubble",
        geojson: munic, 
        values: "POP_2022", 
        fill:"red"
      },
      {
        geojson: munic,
        fill: "#CCC"
      }, 
  ]
})
```

Et en param√©trant un peu, on obtient ceci.

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", //  identifiant de la couche
      type: "bubble", // couche de symboles proportionnels
      geojson: munic, 
      values: "POP_2022", // variable √† cartographier 
      k: 50, // Rayon du plus gros cercle
      leg_x: 740,
      leg_y: 350,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] // infobulle
    },
    {geojson: munic, fill:"#CCC"}, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut facilement combiner cette couche de cercles avec un une carte choropl√®the.

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "white",
      fillOpacity:0.2,
      stroke:"black",
      strokeWidth:1.4,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalit√©\n√©conomique",
            leg_round: 2
        }
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut aussi colorier les cercles

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalit√©\n√©conomique",
            leg_round: 2
        },
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: "#CCC"
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut utiliser les **`Inputs`** pour tester des visualisations, explorer les donn√©es ou proposer des interactions √† un utilisatuer.

```{ojs}
// Inputs
viewof symbology = Inputs.radio(["bubble", "square", "spikes", "smooth", "dotdensity"], { label: "symbologie",   value: "bubble"})
viewof r = Inputs.range([10, 100], { label: "taille", step: 1, value: 50, disabled : ["bubble", "square", "spikes"].includes(symbology) ? false: true})
viewof toggle = Inputs.toggle({label: "dorling", value: false, disabled : ["bubble", "square", "dotdensity"].includes(symbology) ? false: true})
viewof thresholds = Inputs.range([5, 50], { label: "thresholds", step: 1, value: 23, disabled : symbology == "smooth" ? false : true})
viewof bandwidth = Inputs.range([5, 50], { label: "bandwidth", step: 1, value: 27, disabled : symbology == "smooth" ? false : true })
viewof filterpop = Inputs.range([1000, 100000], { label: "POP >= ", step: 1, value: 1000})
// Carte
bertin.draw({
    params: { extent: [[-79, 44.5], [-66, 51]]},
    layers: [
      {
        type: symbology,
        geojson: geo.filter(munic, (d) => d.POP_2022 >= filterpop), 
        values: "POP_2022", 
        fill: symbology == "smooth" ? "RdYlGn" : "red",
        fillOpacity:0.7,
        dorling: toggle,
        k: r,
        thresholds,
        bandwidth,
        symbol_size:25,
        w:15,
        symbol_shift : toggle ? 1 : 0,
        stroke : symbology == "spikes" ? "red" : "white",
        tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
      },
      {
        geojson: munic,
        fill: "#CCC",
        stroke : toggle ? "#CCC" : "white"
      }, 
  ]
})
```

## R√©f√©rences

<ins>Documentation</ins>

-   [github.com/neocarto/bertin](https://github.com/neocarto/bertin)

<ins>Exemples</ins>

-   [observablehq.com/\@neocartocnrs/bertin-js-tooltips?collection=\@neocartocnrs/bertin](https://observablehq.com/@neocartocnrs/bertin-js-tooltips?collection=@neocartocnrs/bertin)
-   Lambert N. (2023) Observable en bref. Webinaire 'Interroger les donn√©es', Groupe de travail 'Atelier Donn√©es' du CNRS. [observablehq.com/\@neocartocnrs/webinaire-interroger-les-donnees](https://observablehq.com/@neocartocnrs/webinaire-interroger-les-donnees)
-   Lambert N. (2023) Cartographie th√©matique avec ojs. √âcole d'√©t√© internationale, Ouidah. [https://ee-cist.github.io/CAR2_cartodyn/intro/docs/index.html](ee-cist.github.io/CAR2_cartodyn/intro/docs/index.html%5D)

## √Ä vous de jouer

::: {.callout-caution appearance="simple"}
## faire des cartes avec {ojs}

::: {.callout-note icon="false"}
## Objectif

R√©aliser comme ci-dessous, une carte [choropl√®the](http://geoconfluences.ens-lyon.fr/glossaire/choroplethe-choroisoplethe) sur une r√©gion du Qu√©bec que l'on peut selectionner dans une liste d√©roulante.

```{ojs}
//| echo: false
//| eval: true
viewof myregion =  Inputs.select(["Estrie","Capitale-Nationale","Bas-Saint-Laurent"], {label: "Choisissez une r√©gion"})
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
bertin.draw({ layers: [{type:"header", text: `Les actifs (${myregion})`},{type:"scalebar"},{ geojson: myreg, rewind: true, fill: {type:"choro", values: "TX_2564", colors: "RdYlGn", leg_x: 2, leg_y:2, leg_title:"Taux d'actifs", leg_round:1}, tooltip:["$MUS_NM_MUN", d => "Taux d'actifs :" + d.properties.TX_2564 + "%"]}] })
```
:::

**A vous de jouer**

-   Chargez la biblioth√®que [`bertin`](https://github.com/neocarto/bertin)
-   Importez la couche `munic.geojson`

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Pour importer des donn√©es au format JSON en Observable JavaScript, on utilise l'instruction `FileAttachment()`
:::

-   Afficher le fond de carte avec la fonction [`draw`](https://github.com/neocarto/bertin#drawing-a-map)

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

La fonction draw prend en entr√©e un objet qui a la structure suivante :

``` js
bertin.draw({
  layers: [{...}]
})
```
:::

::: {.callout-tip icon="false" collapse="true"}
## Astuce

Si la carte ne s'affiche pas correctement, utiliser l'attribut `rewind:true`
:::

-   Afficher les donn√©es attributaires.

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

On peut afficher les donn√©es avec l'instruction. `Inputs.table()` Mais auparavant, il faut r√©cup√©rer les propri√©t√©s du geoJSON comme ceci :

``` js
munic.features.map((d) => d.properties)
```
:::

-   Cr√©er une liste d√©roulante pour choisir parmi 3 r√©gions √† √©tudier

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Par exemple :

``` js
mesregions = ["Estrie","Capitale-Nationale","Bas-Saint-Laurent"]
viewof myregion =  Inputs.select(mesregions, {label: "Choisissez une r√©gion"})
```
:::

-   Cr√©ez un nouveau fond de carte contenant uniquement les municipalit√©s de la r√©gion d√©finie par la liste d√©roulante.

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

Pour cr√©er ce sous jeu de donn√©es, on peut utiliser la fonction `subset` de la biblioth√®que `bertin`.

``` js
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
```
:::

-   Afficher le nouveau fond de carte
-   D√©finisser la couleur de fond, l'√©paisseur des traits, la couleur des contours.
-   R√©aliser une carte [chorpl√®the](https://github.com/neocarto/bertin#choropleth) √† partir d'une variable disponible. Par exemple, le taux d'actifs (TX_2564).

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

D√©finissez l'attribut `fill` par un objet commen√ßant par `{type: choro, values: ...}`
:::

-   Changez les couleurs et la m√©thode de discretisation

::: {.callout-tip icon="false" collapse="true"}
## Besoin d'aide ?

La documentation est disponible [ici](https://github.com/neocarto/bertin#choropleth)
:::

-   Ajouter un [titre](https://github.com/neocarto/bertin#header)
-   Ajouter la l√©gende
-   Ajouter l'[√©chelle](https://github.com/neocarto/bertin#scalebar)
-   Ajoutez des [infobulles](https://observablehq.com/@neocartocnrs/bertin-js-tooltips)

::: {.callout-caution collapse="true"}
## SOLUTION

```{ojs}
//| echo: true
//| eval: false
bertin = require("bertin")
munic = FileAttachment("munic.geojson").json()
viewof myregion = Inputs.select(
  ["Estrie", "Capitale-Nationale", "Bas-Saint-Laurent"],
  { label: "Choisissez une r√©gion" }
)
myreg = bertin.properties.subset({
    geojson: munic,
    field: "MUS_NM_REG",
    selection:   [myregion]
})
bertin.draw({
  layers: [
    { type: "header", text: `Les actifs (${myregion})` },
    { type: "scalebar" },
    {
      geojson: myreg,
      rewind: true,
      fill: {
        type: "choro",
        values: "TX_2564",
        colors: "RdYlGn",
        leg_x: 2,
        leg_y: 2,
        leg_title: "Taux d'actifs",
        leg_round: 1
      },
      tooltip: [
        "$MUS_NM_MUN",
        (d) => "Taux d'actifs :" + d.properties.TX_2564 + "%"
      ]
    }
  ]
})
```
:::
:::

<!-- ## Le petit plus : d√©p√¥t et d√©ploiement continu avec GitHub. -->

