---
title: "Articulation de diff√©rents langages (R, JavaScript et Python) pour la g√©ovisualisation avec Quarto"
subtitle: "Atelier Sageo, Qu√©bec, Juin 2023"
author: "Timoth√©e Giraud, Nicolas Lambert, Matthieu Viry, Ronan Ysebaert (UAR RIATE, CNRS, Universit√© Paris Cit√©)"
format:
  html:
    theme: sandstone
    fontsize: 0.9em
    code-tools: true
    toc: true
    toc-depth: 2
    linkcolor: "#8631ad"
execute: 
  cache: false
---


## Observable JavaScript

### Observable Kezako ?

L'<b>Observable javascript {ojs}</b> est un ensemble d'am√©liorations apport√©es √† vanilla JavaScript cr√©√© par Mike Bostock (√©galement auteur de D3). Observable JS se distingue par son ex√©cution r√©active, qui convient particuli√®rement bien √† l'exploration et √† l'analyse interactives des donn√©es.

![](fig/d3.png){width=20%} ![](fig/arrow.png){width=20%} ![](fig/observable.png){width=20%} <br/>
**Observable** est aussi une startup fond√©e par Mike Bostock et Melody Meckfessel, qui propose une plateforme 100% en ligne ([https://observablehq.com](https://observablehq.com)) pour concevoir, partager et diffuser des visualisations de donn√©es. 

![](fig/frise.png)

**Observable** c'est donc aussi C‚Äôest aussi une plateforme web qui h√©berge des notebooks computationnels sur la visualisation de donn√©es.

üëâ **Objectif** : faire collaborer une communaut√© autour de la visualisation de donn√©es.

### Observable dans Quarto

Le runtime d'Observable est Open Source et est utilis√© dans Quarto. 

Dans Quarto, toutes les instructions s'√©crivent dans des chunks {ojs}

``` {{ojs}}
```

On peut param√©trer l'affiche et/ou l'execution du code avec **//| echo** et **//| eval**.

``` {{ojs}}
//| echo: false
//| eval: true
```

_NB : Contrairement aux chunks R et Python, le code s'execute *just in time* dans le navigateur web une fois le notebook g√©n√©r√©. Seul l'export html est donc pris en compte._


### Principes

Le langage JavaScript n'a pas du √©t√© con√ßu pour l‚Äôanalyse de donn√©es. Mais, gros point fort, on a tous un navigateur web et JavaScript tourne sur toutes les machines. Le but : b√¢tir une √©volution du langage JavaScript pour en faire un langage adapt√© √† l‚Äôanalyse et la visualisation de donn√©es sur le web. 

#### üëâ Des biblioth√®ques pr√©charg√©es üìä

OJS c'est du JavaScript + plein de biblioth√®ques pr√© charg√©es : <br/>

| Symbol   | Name              | Version            |
|----------|-------------------|--------------------|
| \_       | Lodash            | 4.17.21            |
| aq       | Arquero           | \${aq.version}     |
| Arrow    | Apache Arrow      | 4.0.1              |
| d3       | D3.js             | \${d3.version}     |
| dot      | Graphviz          | 0.2.1              |
| htl      | Hypertext Literal | \${htl.version}    |
| Inputs   | Observable Inputs | \${Inputs.version} |
| L        | Leaflet           | \${L.version}      |
| mermaid  | Mermaid           | 9.1.6              |
| Plot     | Observable Plot   | \${Plot.version}   |
| SQLite   | SQL.js            | 1.7.0              |
| topojson | TopoJSON Client   | 3.1.0              |
| vl       | Vega, Vega-Lite   | 5.22.1, 5.2.0      |

#### üëâ Chaque d√©but de ligne identifie une cellule ojs üôã

Chaque ligne d√©finit une variable et une cellule qui doit √™tre unique sur l'ensemble du document.

``` {{ojs}}
a = 10 // une cellule
b = 20 // une cellule
```

``` {{ojs}}
c = a + b // une cellule
```

``` {{ojs}}
d = { 
  let a = 10 
  let b = 30
  return a + b 
} // Une cellule
```

#### üëâ L‚Äôordre des cellules n‚Äôa pas d‚Äôimportance ü§Ø

On peut donc √©crire √ßa

``` {{ojs}}
result = val1 * val2
```

avant √ßa

``` {{ojs}}
val1 = 10
val2 = 20
```

Le lien entre les cellules se fait de fa√ßon topologique et non de haut en bas. 

![](fig/topology.png)

#### üëâ Tout est r√©actif üî•

D√®s lors qu'une cellule est modifi√©e, les cellules qui en d√©pendent sont modifi√©es √©galement.

Pour modifier la valeutr d'une c√©llule, on utilise des **`Inputs`** (des composants propos√©s par OJS pour explorer les donn√©es) avec le mot cl√© **`viewof`**. Voir : https://observablehq.com/@observablehq/inputs


```{ojs}
viewof x = Inputs.range([0, 255], {step: 1})
```

```{ojs}
viewof y = Inputs.text({value: 30})
```

```{ojs}
viewof z = Inputs.radio([10, 100, 1000], {value: 10})
```

```{ojs}
x * y * z
```

Ce syst√®me est pratique pour modifier des visualisations de donn√©es.

Ici, un exemple avec un simple cercle dessin√© en svg.

```{ojs}
viewof color = Inputs.color({ label: "Couleur", value: "#4ab58c" })
viewof radius = Inputs.range([1, 50], { label: "Rayon", step: 1, value: 100 })
viewof position = Inputs.range([50, 950], { label: "Position", step: 1, value: 50 })
```

```{ojs}
html`<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">
  <circle cx=${position} cy="50" r=${radius} fill="${color}"/>
</svg>`
```

### l'√©cosyst√®me spatial avec Ojs

L'√©cosyst√®me spatial de JavaScript est moins √©toff√© que ce qu'on peut trouver en Python ou en R. Mais on trouve quand m√™me des choses int√©ressantes qui permettent de faire de la g√©omatique directement dans le navigateur web. Voici quelques exemples.

**Les fonctionnalit√©s spatiales de `d3.js`**

::: columns
::: {.column width="8%"}
![](fig/d3.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`d3-geo`**](https://github.com/d3/d3-geo) est le module spatial de d3. Il permet de g√©rer les projections cartographiques, les formes sph√©riques et la trigonom√©trie sph√©rique. Voir aussi [**`d3-geo-projection`**](https://github.com/d3/d3-geo-projection). [**`d3-delaunay`**](https://github.com/d3/d3-delaunay) est une biblioth√®que rapide pour calculer le diagramme de Vorono√Ø d'un ensemble de points bidimensionnels. Elle est bas√©e sur Delaunator, une biblioth√®que rapide pour calculer la triangulation de Delaunay en utilisant des algorithmes de balayage. Le diagramme de Vorono√Ø est construit en reliant les circonf√©rences des triangles adjacents dans la triangulation de Delaunay. [**`d3-geo-voronoi`**](https://github.com/Fil/d3-geo-voronoi) est une adaptation de d3-delaunay sur la sph√®re.
:::
::::


::: columns
::: {.column width="8%"}
![](fig/topojson.svg)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`TopoJSON`**](https://github.com/topojson/topojson)  est une extension de GeoJSON. La librairie permet de r√©aliser des op√©rations SIG bas√©es sur la topologie (agr√©gation, voisins, simplification, etc.)
:::
::::

**Les biblioth√®ques SIG**

::: columns
::: {.column width="8%"}
![](fig/turf.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`turf`**](https://turfjs.org/) est une biblioth√®que JavaScript pour l'analyse spatiale (de type SIG). Elle comprend les op√©rations spatiales traditionnelles, des fonctions d'aide pour la cr√©ation de donn√©es GeoJSON, ainsi que des outils de classification des donn√©es et de statistiques. L'avantage de turf est d'√™tre modulaire. On ne charge que ce dont on a besoin.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/spljs.jpg)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`spl.js`**](https://turfjs.org/) est une impl√©mentation de SpatiaLite (et de ses amis : sqlite, geos, proj, rttopo) pour le navigateur.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/geotoolbox.svg)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`geotoolbox`**](https://github.com/neocarto/geotoolbox) est un outil javascript pour les g√©ographes bas√© sur d3geo, topojson et jsts. Il permet de traiter simplement les propri√©t√©s geojson et fournit plusieurs op√©rations SIG utiles pour la cartographie th√©matique.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/gdal.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`Gdals3.js`**](https://github.com/bugra9/gdal3.js) est un portage des applications Gdal (gdal_translate, ogr2ogr, gdal_rasterize, gdalwarp, gdaltransform) vers Webassembly. Il permet de convertir des donn√©es g√©ospatiales matricielles et vectorielles dans divers formats et syst√®mes de coordonn√©es.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/proj4.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`proj4js`**](http://proj4js.org/) est une biblioth√®que JavaScript permettant de transformer les coordonn√©es d'un syst√®me de coordonn√©es √† un autre, y compris les transformations de datum
:::
::::

**Dataviz / cartographie**

::: columns
::: {.column width="8%"}
![](fig/plot.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`plot`**](https://observablehq.com/plot/) est la biblioth√®que de visualisation de donn√©e d√©velopp√©e par Observable (Mike Bostock et Philippe Rivi√®re). Au d√©part pens√©e pour la visualisation de donn√©es statistiques, elle permet aujourd'hui de r√©aliser des cartes. Plot est disponible par d√©faut dans les cellules {ojs}.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/vega.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`vega-lite`**](https://github.com/vega/vega-lite) est un outil de visualisation mettant en ≈ìuvre une grammaire graphique, similaire √† ggplot2. Cette biblioth√®que est disponible par d√©faut dans les cellules {ojs}.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/bertin.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`bertin`**](https://github.com/neocarto/bertin) est une biblioth√®que √©crite en JavaScript qui permet de r√©aliser des cartes th√©matiques pour le web. Sa conception vise √† permettre aux utilisateurs de cr√©er rapidement des cartes th√©matiques interactives sans forcement conna√Ætre le langage JavaScript.
:::
::::


::: columns
::: {.column width="8%"}
![](fig/gridviz.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`Gridviz`**](https://github.com/eurostat/gridviz) est une biblioth√®que JavaScript bas√©e sur WebGL d√©velopp√©e par Julien Gaffuri et Joe Davies. Elle permet de visualiser des donn√©es carroy√©es (ou tout ensemble de donn√©es tabulaires avec une position x/y) dans le navigateur dans une grande vari√©t√© de styles cartographiques. 
:::
::::

::: columns
::: {.column width="8%"}
![](fig/logo-go-cart-wasm.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`go-cart-wasm`**](https://github.com/riatelab/go-cart-wasm) est une biblioth√®que JS/WASM permettant de r√©aliser des cartogrammes bas√©s sur le flux (comme d√©crit dans "Gastner, Seguy, and More (2018). 
:::
::::


### Importer des donn√©es

Pour importer des donn√©es en **`{ojs}`**, on utilise l'instruction **`FileAttachment()`** 

Pour un fichier JSON 

```js
mrc = FileAttachment("geom/mrc.geojson").json()
munic = FileAttachment("geom/munic.geojson").json()
```

Pour un fichier csv

```js
FileAttachment("data.csv").csv({typed: true})
```

On peut aussi r√©cup√©rer des donn√©es depuis R ou Python avec l'instruction **`ojs_define`**

```{ojs}
//| eval: false
//| echo: true
mrc = FileAttachment("geom/mrc.geojson").json()
munic = FileAttachment("geom/munic.geojson").json()
```



```{ojs}
//| eval: true
//| echo: false
tmp = FileAttachment("geom/munic.geojson").json()
munic =  geo.rewind(geo.simplify(tmp, {k:0.1}))
tmp2 = FileAttachment("geom/mrc.geojson").json()
mrc =  geo.rewind(geo.simplify(tmp2, {k:0.1}))

```

### Visualiser les donn√©es stats

Pour regarder la table attributaire, on utilise **`Inputs.table()`**

```{ojs}
Inputs.table(munic.features.map(d => d.properties))
```

Avec **`{ojs}`**, on va aussi pouvoir faire des graphiques avec la biblioth√®que **`plot`**. Pour cela, on fait quelques manipulations de donn√©es.

Tout d'abord, on r√©cup√®re les noms des 20 communes les plus peupl√©es, class√©es par ordre d√©croissant de population.

```{ojs}
communes = munic.features
  .map((d) => d.properties)
  .sort((a, b) => d3.descending(a.POP_2022, b.POP_2022))
  .map((d) => d.MUS_NM_MUN)
  .slice(0, 20)
```

```{ojs}
//| echo: false
//| eval: true
communes
```

On met en forme les donn√©es. 

```{ojs}
data = {
  let arr = [];
  communes.forEach((d) => {
    let tmp = munic.features
      .map((d) => d.properties)
      .find((x) => x.MUS_NM_MUN == d);
    for (let i = 2001; i <= 2022; i++) {
      arr.push({ year: i, pop: tmp["POP_" + i], com: d });
    }
  });
  return arr;
}
```

```{ojs}
//| echo: false
//| eval: true
Inputs.table(data, {width:250, height:250})
```

Puis on r√©alise le graphique avec `plot` en proposant de s√©lectionner une commune.

```{ojs}
viewof commune = Inputs.select(communes, { label: "Commune" })
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population (${commune})`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data.filter(d => d.com == commune), {
      x: "year",
      y: "pop",
      stroke: "red",
      strokeWidth: 2
    })
  ]
})
```

### Visualiser les g√©m√©tries

Comme leaflet est disponible dans les cellules {ojs}, on peut directement afficher les g√©om√©tries.

```{ojs}
{
  const container = yield htl.html`<div style="height: 500px;">`;
  const map = L.map(container);
  const layer = L.geoJSON(mrc).addTo(map);
  map.fitBounds(layer.getBounds(), { maxZoom: 9 });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution:
      "¬© <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors"
  }).addTo(map);
}
```

On peut √©galement afficher la carte simplement avec la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin).

```{ojs}
bertin = require("bertin")
```

```{ojs}
bertin.quickdraw(mrc)
```

### Un peu de SIG

La bibioth√®que **`geotoolbox`** permet de faire facilement differentes operations SIG.

```{ojs}
geo = require("geotoolbox")
```

- **Simplification**


```{ojs}
viewof simpl = Inputs.range([0.0001, 0.2], { label: "Simplification",  value: 0.1 })
mrc2 = geo.simplify(mrc, { k: simpl })
```

```{ojs}
//| echo: false
bertin.draw({params:{extent: munic},layers:[{geojson: mrc2, stroke:"black", strokeWidth:1.5, fill:"white", rewind: true}]})
```

- **Centroid**

```{ojs}
ctr = geo.centroid(mrc)
```
```{ojs}
//| echo: false
bertin.draw({params:{extent: mrc}, layers:[{geojson: ctr, fill:"red"},{geojson: mrc, fill:"#CCC"}, ]}) 
```

- **Buffer**

```{ojs}
quebec = geo.filter(mrc, (d) => d.MUS_CO_MRC == "23")
buff = geo.buffer(quebec, { dist: distance})
ctr2 = geo.clip(ctr, {clip: buff})
```

```{ojs}
//| echo: false
viewof distance = Inputs.range([0, 500], {
  label: "Distance",
  value: 300,
  step: 10
})
bertin.draw({layers:[{geojson: quebec, fill:"red"}, {geojson: ctr2, fill:"red"}, {geojson: buff, stroke:"red", fill: "none", strokeWidth:2},{geojson: mrc, fill:"#CCC"}, ]}) 
```

**Cr√©ation de cartes th√©matiques**

Pour cr√©er des cartes th√©matiques, on peut utiliser la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin)


La fonction **`draw`** permet de r√©aliser n'importe quel type de carte. 

![](fig/bertin_code.png)

Par d√©faut, la couche s'affiche simplement.

```{ojs}
bertin.draw({layers:[{geojson: munic, fill: "#d18de0"}]})
```

On peut ajouter l'attrubut **`tooltip`** pour afficher des infobulles.

```{ojs}
bertin.draw({
  layers:[
    { 
      geojson: munic, fill: "#d18de0",
      tooltip: "$MUS_NM_MUN"
    }
  ]
})
```

**Cartographie th√©matique**

A pr√©sent, r√©alisons une carte de la population en 2022. Pour cela, on utilise le type **`bubble`**.

Par d√©faut, √ßa donne ceci :

```{ojs}
bertin.draw({
    layers: [
      {
        type: "bubble",
        geojson: munic, 
        values: "POP_2022", 
        fill:"red"
      },
      {
        geojson: munic,
        fill: "#CCC"
      }, 
  ]
})
```

Et en param√©trant un peu, on obtient ceci.


```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", //  identifiant de la couche
      type: "bubble", // couche de symboles proportionnels
      geojson: munic, 
      values: "POP_2022", // variable √† cartographier 
      k: 50, // Rayon du plus gros cercle
      leg_x: 740,
      leg_y: 350,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] // infobulle
    },
    {geojson: munic, fill:"#CCC"}, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut facilement combiner cette couche de cercles avec un une carte choropl√®the.


```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: "white",
      fillOpacity:0.2,
      stroke:"black",
      strokeWidth:1.4,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalit√©\n√©conomique",
            leg_round: 2
        }
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```

On peut aussi colorier les cercles

```{ojs}
bertin.draw({
  params: { extent: [[-79, 44.5], [-66, 51]]},
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 10, y: 10, width: 160 }, 
    {
      id : "bub", 
      type: "bubble", 
      geojson: munic, 
      values: "POP_2022", 
      k: 50, 
      leg_x: 690,
      leg_y: 370,
      leg_round: 0,
      leg_title: "Nombre d'habitants",
      fill: {
            type: "choro",
            values: "VIT_ECO", 
            colors: "RdYlBu",
            leg_x:870,
            leg_y:315,
            leg_title: "Indice de\nvitalit√©\n√©conomique",
            leg_round: 2
        },
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
    },
    { 
      geojson: munic,
      fill: "#CCC"
    }, // Couche des communes
    {type:"scalebar"}
  ]
})
```



On peut utiliser les **`Inputs`** pour tester des visualisations, explorer les donn√©es ou proposer des interactions √† un utilisatuer.

```{ojs}
// Inputs
viewof symbology = Inputs.radio(["bubble", "square", "spikes", "smooth", "dotdensity"], { label: "symbologie",   value: "bubble"})
viewof r = Inputs.range([10, 100], { label: "taille", step: 1, value: 50, disabled : ["bubble", "square", "spikes"].includes(symbology) ? false: true})
viewof toggle = Inputs.toggle({label: "dorling", value: false, disabled : ["bubble", "square", "dotdensity"].includes(symbology) ? false: true})
viewof thresholds = Inputs.range([5, 50], { label: "thresholds", step: 1, value: 23, disabled : symbology == "smooth" ? false : true})
viewof bandwidth = Inputs.range([5, 50], { label: "bandwidth", step: 1, value: 27, disabled : symbology == "smooth" ? false : true })
viewof filterpop = Inputs.range([1000, 100000], { label: "POP >= ", step: 1, value: 1000})
// Carte
bertin.draw({
    params: { extent: [[-79, 44.5], [-66, 51]]},
    layers: [
      {
        type: symbology,
        geojson: geo.filter(munic, (d) => d.POP_2022 >= filterpop), 
        values: "POP_2022", 
        fill: symbology == "smooth" ? "RdYlGn" : "red",
        fillOpacity:0.7,
        dorling: toggle,
        k: r,
        thresholds,
        bandwidth,
        symbol_size:25,
        w:15,
        symbol_shift : toggle ? 1 : 0,
        stroke : symbology == "spikes" ? "red" : "white",
        tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"] + " habitants"] 
      },
      {
        geojson: munic,
        fill: "#CCC",
        stroke : toggle ? "#CCC" : "white"
      }, 
  ]
})
```

**Cartographie de donn√©es raster**

Pour cartographier des donn√©es raster, on peut utiliser la biblioth√®que **`gridviz`**.

TODO.....

```{ojs}
gviz = require("gridviz@2.0.6")
```

