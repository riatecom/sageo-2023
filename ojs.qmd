---
title: "Articulation de diff√©rents langages (R, JavaScript et Python) pour la g√©ovisualisation avec Quarto"
subtitle: "Atelier Sageo, Qu√©bec, Juin 2023"
author: "Timoth√©e Giraud, Nicolas Lambert, Matthieu Viry, Ronan Ysebaert (UAR RIATE, CNRS, Universit√© Paris Cit√©)"
format:
  html:
    theme: sandstone
    fontsize: 0.9em
    code-tools: true
    toc: true
    toc-depth: 2
    linkcolor: "#8631ad"
execute: 
  cache: false
---


## Observable JavaScript

### Observable Kezako ?

L'<b>Observable javascript {ojs}</b> est un ensemble d'am√©liorations apport√©es √† vanilla JavaScript cr√©√© par Mike Bostock (√©galement auteur de D3). Observable JS se distingue par son ex√©cution r√©active, qui convient particuli√®rement bien √† l'exploration et √† l'analyse interactives des donn√©es.

![](fig/d3.png){width=20%} ![](fig/arrow.png){width=20%} ![](fig/observable.png){width=20%} <br/>
**Observable** est aussi une startup fond√©e par Mike Bostock et Melody Meckfessel, qui propose une plateforme 100% en ligne ([https://observablehq.com](https://observablehq.com)) pour concevoir, partager et diffuser des visualisations de donn√©es. 

![](fig/frise.png)

**Observable** c'est donc aussi C‚Äôest aussi une plateforme web qui h√©berge des notebooks computationnels sur la visualisation de donn√©es.

üëâ **Objectif** : faire collaborer une communaut√© autour de la visualisation de donn√©es.

### Observable dans Quarto

Le runtime d'Observable est Open Source et est utilis√© dans Quarto. 

Dans Quarto, toutes les instructions s'√©crivent dans des chunks {ojs}

``` {{ojs}}
```

On peut param√©trer l'affiche et/ou l'execution du code avec **//| echo** et **//| eval**.

``` {{ojs}}
//| echo: false
//| eval: true
```

_NB : Contrairement aux chunks R et Python, le code s'execute *just in time* dans le navigateur web une fois le notebook g√©n√©r√©. Seul l'export html est donc pris en compte._


### Principes

Le langage JavaScript n'a pas du √©t√© con√ßu pour l‚Äôanalyse de donn√©es. Mais, gros point fort, on a tous un navigateur web et JavaScript tourne sur toutes les machines. Le but : b√¢tir une √©volution du langage JavaScript pour en faire un langage adapt√© √† l‚Äôanalyse et la visualisation de donn√©es sur le web. 

#### üëâ Des biblioth√®ques pr√©charg√©es üìä

OJS c'est du JavaScript + plein de biblioth√®ques pr√© charg√©es : <br/>

| Symbol   | Name              | Version            |
|----------|-------------------|--------------------|
| \_       | Lodash            | 4.17.21            |
| aq       | Arquero           | \${aq.version}     |
| Arrow    | Apache Arrow      | 4.0.1              |
| d3       | D3.js             | \${d3.version}     |
| dot      | Graphviz          | 0.2.1              |
| htl      | Hypertext Literal | \${htl.version}    |
| Inputs   | Observable Inputs | \${Inputs.version} |
| L        | Leaflet           | \${L.version}      |
| mermaid  | Mermaid           | 9.1.6              |
| Plot     | Observable Plot   | \${Plot.version}   |
| SQLite   | SQL.js            | 1.7.0              |
| topojson | TopoJSON Client   | 3.1.0              |
| vl       | Vega, Vega-Lite   | 5.22.1, 5.2.0      |

#### üëâ Chaque d√©but de ligne identifie une cellule ojs üôã

Chaque ligne d√©finit une variable et une cellule qui doit √™tre unique sur l'ensemble du document.

``` {{ojs}}
a = 10 // une cellule
b = 20 // une cellule
```

``` {{ojs}}
c = a + b // une cellule
```

``` {{ojs}}
d = { 
  let a = 10 
  let b = 30
  return a + b 
} // Une cellule
```

#### üëâ L‚Äôordre des cellules n‚Äôa pas d‚Äôimportance ü§Ø

On peut donc √©crire √ßa

``` {{ojs}}
result = val1 * val2
```

avant √ßa

``` {{ojs}}
val1 = 10
val2 = 20
```

Le lien entre les cellules se fait de fa√ßon topologique et non de haut en bas. 

![](fig/topology.png)

#### üëâ Tout est r√©actif üî•

D√®s lors qu'une cellule est modifi√©e, les cellules qui en d√©pendent sont modifi√©es √©galement.

Pour modifier la valeutr d'une c√©llule, on utilise des **`Inputs`** (des composants propos√©s par OJS pour explorer les donn√©es) avec le mot cl√© **`viewof`**. Voir : https://observablehq.com/@observablehq/inputs


```{ojs}
viewof x = Inputs.range([0, 255], {step: 1})
```

```{ojs}
viewof y = Inputs.text({value: 30})
```

```{ojs}
viewof z = Inputs.radio([10, 100, 1000], {value: 10})
```

```{ojs}
x * y * z
```

Ce syst√®me est pratique pour modifier des visualisations de donn√©es.

Ici, un exemple avec un simple cercle dessin√© en svg.

```{ojs}
viewof color = Inputs.color({ label: "Couleur", value: "#4ab58c" })
viewof radius = Inputs.range([1, 50], { label: "Rayon", step: 1, value: 100 })
viewof position = Inputs.range([50, 950], { label: "Position", step: 1, value: 50 })
```

```{ojs}
html`<svg viewBox="0 0 1000 100" xmlns="http://www.w3.org/2000/svg">
  <circle cx=${position} cy="50" r=${radius} fill="${color}"/>
</svg>`
```

### l'√©cosyst√®me spatial avec Ojs

L'√©cosyst√®me spatial de JavaScript est moins √©toff√© que ce qu'on peut trouver en Python ou en R. Mais on trouve quand m√™me des choses int√©ressantes qui permettent de faire de la g√©omatique directement dans le navigateur web. Voici quelques exemples.

**Les fonctionnalit√©s spatiales de `d3.js`**

::: columns
::: {.column width="8%"}
![](fig/d3.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`d3-geo`**](https://github.com/d3/d3-geo) est le module spatial de d3. Il permet de g√©rer les projections cartographiques, les formes sph√©riques et la trigonom√©trie sph√©rique. Voir aussi [**`d3-geo-projection`**](https://github.com/d3/d3-geo-projection). [**`d3-delaunay`**](https://github.com/d3/d3-delaunay) est une biblioth√®que rapide pour calculer le diagramme de Vorono√Ø d'un ensemble de points bidimensionnels. Elle est bas√©e sur Delaunator, une biblioth√®que rapide pour calculer la triangulation de Delaunay en utilisant des algorithmes de balayage. Le diagramme de Vorono√Ø est construit en reliant les circonf√©rences des triangles adjacents dans la triangulation de Delaunay. [**`d3-geo-voronoi`**](https://github.com/Fil/d3-geo-voronoi) est une adaptation de d3-delaunay sur la sph√®re.
:::
::::


::: columns
::: {.column width="8%"}
![](fig/topojson.svg)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`TopoJSON`**](https://github.com/topojson/topojson)  est une extension de GeoJSON. La librairie permet de r√©aliser des op√©rations SIG bas√©es sur la topologie (agr√©gation, voisins, simplification, etc.)
:::
::::

**Les biblioth√®ques SIG**

::: columns
::: {.column width="8%"}
![](fig/turf.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`turf`**](https://turfjs.org/) est une biblioth√®que JavaScript pour l'analyse spatiale (de type SIG). Elle comprend les op√©rations spatiales traditionnelles, des fonctions d'aide pour la cr√©ation de donn√©es GeoJSON, ainsi que des outils de classification des donn√©es et de statistiques. L'avantage de turf est d'√™tre modulaire. On ne charge que ce dont on a besoin.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/spljs.jpg)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`spl.js`**](https://turfjs.org/) est une impl√©mentation de SpatiaLite (et de ses amis : sqlite, geos, proj, rttopo) pour le navigateur.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/geotoolbox.svg)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`geotoolbox`**](https://github.com/neocarto/geotoolbox) est un outil javascript pour les g√©ographes bas√© sur d3geo, topojson et jsts. Il permet de traiter simplement les propri√©t√©s geojson et fournit plusieurs op√©rations SIG utiles pour la cartographie th√©matique.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/gdal.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`Gdals3.js`**](https://github.com/bugra9/gdal3.js) est un portage des applications Gdal (gdal_translate, ogr2ogr, gdal_rasterize, gdalwarp, gdaltransform) vers Webassembly. Il permet de convertir des donn√©es g√©ospatiales matricielles et vectorielles dans divers formats et syst√®mes de coordonn√©es.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/proj4.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`proj4js`**](http://proj4js.org/) est une biblioth√®que JavaScript permettant de transformer les coordonn√©es d'un syst√®me de coordonn√©es √† un autre, y compris les transformations de datum
:::
::::

**Dataviz / cartographie**

::: columns
::: {.column width="8%"}
![](fig/plot.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`plot`**](https://observablehq.com/plot/) est la biblioth√®que de visualisation de donn√©e d√©velopp√©e par Observable (Mike Bostock et Philippe Rivi√®re). Au d√©part pens√©e pour la visualisation de donn√©es statistiques, elle permet aujourd'hui de r√©aliser des cartes. Plot est disponible par d√©faut dans les cellules {ojs}.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/vega.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`vega-lite`**](https://github.com/vega/vega-lite) est un outil de visualisation mettant en ≈ìuvre une grammaire graphique, similaire √† ggplot2. Cette biblioth√®que est disponible par d√©faut dans les cellules {ojs}.
:::
::::

::: columns
::: {.column width="8%"}
![](fig/bertin.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`bertin`**](https://github.com/neocarto/bertin) est une biblioth√®que √©crite en JavaScript qui permet de r√©aliser des cartes th√©matiques pour le web. Sa conception vise √† permettre aux utilisateurs de cr√©er rapidement des cartes th√©matiques interactives sans forcement conna√Ætre le langage JavaScript.
:::
::::


::: columns
::: {.column width="8%"}
![](fig/gridviz.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`Gridviz`**](https://github.com/eurostat/gridviz) est une biblioth√®que JavaScript bas√©e sur WebGL d√©velopp√©e par Julien Gaffuri et Joe Davies. Elle permet de visualiser des donn√©es carroy√©es (ou tout ensemble de donn√©es tabulaires avec une position x/y) dans le navigateur dans une grande vari√©t√© de styles cartographiques. 
:::
::::

::: columns
::: {.column width="8%"}
![](fig/logo-go-cart-wasm.png)
::::
::: {.column width="2%"}
:::
::: {.column width="90%"}
[**`go-cart-wasm`**](https://github.com/riatelab/go-cart-wasm) est une biblioth√®que JS/WASM permettant de r√©aliser des cartogrammes bas√©s sur le flux (comme d√©crit dans "Gastner, Seguy, and More (2018). 
:::
::::

### Cartographie interactive avec Observable JavaScript

On souhaite √† pr√©sent r√©aliser une carte interactive √† l'√©chelle des municipalit√©s. 

Tout d'abord, on r√©cp√®re les donn√©es depuis R (**TODO**)

```{ojs}
munic = FileAttachment("geom/munic.geojson").json()
```

Regardons la table attributaire

```{ojs}
Inputs.table(munic.features.map(d => d.properties))
```

Comme leaflet est disponible dans les cellules {ojs}, on peut directement afficher les g√©om√©tries.

```{ojs}
{
  const container = yield htl.html`<div style="height: 500px;">`;
  const map = L.map(container);
  const layer = L.geoJSON(munic).addTo(map);
  map.fitBounds(layer.getBounds(), { maxZoom: 9 });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution:
      "¬© <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors"
  }).addTo(map);
}
```

Le fond de carte n'est pas assez simplifi√©. Donc on le simplifie et on le nettoie avec la bibioth√®que **`geotoolbox`**.

```{ojs}
geo = require("geotoolbox")
```

```{ojs}
munic2 = geo.rewind(geo.simplify(munic, { k: 0.02 }))
```

**Cr√©ation de cartes th√©matiques**

Pour cr√©er des cartes th√©matiques, on peut utiliser la biblioth√®que [**`bertin`**](https://github.com/neocarto/bertin)

```{ojs}
bertin = require("bertin")
```

La fonction **`draw`** permet de r√©aliser n'importe quel type de carte. 

![](fig/bertin_code.png)

Par d√©faut, la couche s'affiche simplement.

```{ojs}
bertin.draw({layers:[{geojson: munic2, fill: "#d18de0"}]})
```

**Cartographie th√©matique**

A pr√©sent, r√©alisons une carte de la population en 2022. Pour cela, on utilise le type **`bubble`**.

```{ojs}
bertin.draw({
  params: { margin: [-550, 0, 50, 0]}, // marges [Haut, droite, bas, gauche]
  layers: [
    { type: "header", text: "Population en 2022", anchor: "start" }, // Titre
    { type: "minimap", x: 30, y: 185, width: 90, projection:"Polar" }, // Carte de localisation
    {
      id : "bub", //  identifiant de la couche
      type: "bubble", // couche de symboles proportionnels
      geojson: munic2, 
      values: "POP_2022", // variable √† cartographier 
      k: 30, // Rayon du plus gros cercle
      leg_x: 500,
      leg_y: 130,
      leg_round: 0,
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"]] // infobulle
    },
    {geojson: munic2, fill:"#CCC"}, // Couche des communes
  ]
})
```




::: {.callout-caution}
## A vous de jouer - Rendez la carte interactive avec {ojs}

Pour rendre la carte interactive, vous avez pouvez proposer des `Inputs` pour interagir avec l'utilisateur.

Ajoutez un Input de type `radio` pour d√©finir la symbologie : [**`bubble`**](https://github.com/neocarto/bertin#bubble), [**`square`**](https://github.com/neocarto/bertin#square) et [**`spikes`**](https://github.com/neocarto/bertin#spikes)



```js
viewof symbol = Inputs.radio([`a`, `b`, `c`], { label: `label`,  value: `valeur par d√©faut`})
```

Cr√©ez une liste d√©roulante pour changer la variable √† cartographier. Pare exemple, la population et la surface.

```js
viewof val = Inputs.select(["A", "B"], {label: "Select one"})
```

Cr√©ez un slider pouyr faire varier la taille des cercles

```js
viewof rayon = Inputs.range([`min`, `max`], { label: "label", step: 1, value: 30 })
```

Modifiez la carte pr√©c√©dente pour prendre en compte ces valeurs.
 
Utilisez `//| echo: false` pour masquer le code.

Pour en savoir plus sur les `inputs`, voir : [@observablehq/inputs](https://observablehq.com/@observablehq/inputs)

:::

::: {.callout-tip collapse="true"}
## Solution

Les Inputs

```{ojs}
//| echo: true
//| eval: false
viewof symbol = Inputs.radio([`bubble`, `square`], { label: `Symbol`,  value: `bubble`})
viewof val = Inputs.select(["POP_2022", "AREA"], {label: "Variable"})
viewof rayon = Inputs.range([1, 100], { label: "Rayon", step: 2, value: 30 })
```

Pour adater le titre de la carte en fonction de la variable, on peut faire

```{ojs}
//| echo: true
//| eval: false
title = val == "AREA" ? "Superficie" : "Population en 2022"
```

Et la carte

```{ojs}
//| echo: true
//| eval: false
bertin.draw({
  params: { margin: [-550, 0, 50, 0]},
  layers: [
    { type: "header", text: title, anchor: "start" }, // ICI
    { type: "minimap", x: 30, y: 185, width: 90, projection:"Polar" }, 
    {
      type: symbol, // ICI 
      geojson: munic2, 
      values: val, // ICI
      k: rayon, // ICI
      leg_x: 500,
      leg_y: 130,
      leg_round: 0,
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"]] 
    },
    {geojson: munic2, fill:"#CCC"},
  ]
})
```

```{ojs}
//| echo: false
//| eval: true
viewof symbol = Inputs.radio([`bubble`, `square`], { label: `Symbol`,  value: `bubble`})
viewof val = Inputs.select(["POP_2022", "AREA"], {label: "Variable"})
viewof rayon = Inputs.range([1, 100], { label: "Rayon", step: 2, value: 30 })
title = val == "AREA" ? "Superficie" : "Population en 2022"
bertin.draw({
  params: { margin: [-550, 0, 50, 0]},
  layers: [
    { type: "header", text: title, anchor: "start" },
    { type: "minimap", x: 30, y: 185, width: 90, projection:"Polar" }, 
    {
      type: symbol, 
      geojson: munic2, 
      values: val, 
      k: rayon,
      leg_x: 500,
      leg_y: 130,
      leg_round: 0,
      fill: "red",
      fillOpacity:0.5,
      tooltip: ["$MUS_NM_MUN", d => d.properties["POP_2022"]] 
    },
    {geojson: munic2, fill:"#CCC"},
  ]
})
```
:::

A pr√©sent, on souhaite colorier les cercles en fonction de l'indice de vitalit√© √©conomique. 

::: {.callout-caution}
## A vous de jouer

Pour faire des varriations de couleurs (i.e. valeur), on utilise le type `**choro**` √† l'int√©rieur de l'attribut **`fill`** de la couche √† colorier. Ici, les cercles proportionnels.

```js
fill : {type "choro", values: `votre variable`, colors: "RdYlBu"}
```

Pour param√©trer, voir : [bertin#choropleth](https://github.com/neocarto/bertin#choropleth) & [bertin-js-chropoleth](https://observablehq.com/@neocartocnrs/bertin-js-chropoleth?collection=@neocartocnrs/bertin)
:::

::: {.callout-tip collapse="true"}
## Solution
```{ojs}


bertin.draw({
  params: { margin: [-550, 0, 50, 0]},
  layers: [
    { type: "header", text: title, anchor: "start" },
    { type: "minimap", x: 30, y: 185, width: 90, projection:"Polar" }, 
    {
      type: symbol, 
      geojson: munic2, 
      values: val, 
      k: rayon,
      leg_x: 500,
      leg_y: 130,
      leg_round: 0,
      fill: { // ICI
        type: "choro",
        values: "VIT_ECO",
        colors: "RdYlBu",
        leg_x:680,
        leg_y:100,
        leg_title:
        "Vitalit√© √©conomique",
        leg_round: 0
        },
      fillOpacity:0.8,
      tooltip: ["$MUS_NM_MUN", d => d.properties["VIT_ECO"]] 
    },
    {geojson: munic2, fill:"#CCC"},
  ]
})
```
:::

**Cr√©ation de graphiques**

Avec **`{ojs}`**, on va aussi pouvoir faire des graphiques avec la biblioth√®que **`plot`**.

Tout d'abord, on r√©cup√®re les noms des 20 communes les plus peupl√©es, class√©es par ordre d√©croissant de population.

```{ojs}
communes = munic2.features
  .map((d) => d.properties)
  .sort((a, b) => d3.descending(a.POP_2022, b.POP_2022))
  .map((d) => d.MUS_NM_MUN)
  .slice(0, 20)
```

```{ojs}
//| echo: false
//| eval: true
communes
```

On met en forme les donn√©es. 

```{ojs}
data = {
  let arr = [];
  communes.forEach((d) => {
    let tmp = munic2.features
      .map((d) => d.properties)
      .find((x) => x.MUS_NM_MUN == d);
    for (let i = 2001; i <= 2022; i++) {
      arr.push({ year: i, pop: tmp["POP_" + i], com: d });
    }
  });
  return arr;
}
```

```{ojs}
//| echo: false
//| eval: true
data
```

Puis on r√©alise le graphique avec `plot` en proposant de s√©lectionner une commune.



```{ojs}
viewof commune = Inputs.select(communes, { label: "Commune" })
Plot.plot({
  grid: true,
  x: {
    label: "Ann√©es ‚Üí",
    tickFormat: ""
  },
  y: {
    label: `‚Üë Population (${commune})`
  },
  color: { legend: true },
  marginLeft: 60,
  marks: [
    Plot.lineY(data.filter(d => d.com == commune), {
      x: "year",
      y: "pop",
      stroke: "red",
      strokeWidth: 2
    })
  ]
})
```

**Cartographie de donn√©es raster**


