---
title: "Articulation de différents langages (R, JavaScript et Python) pour la géovisualisation avec Quarto"
subtitle: "SAGEO, 2023 - Québec, Canada"
author: "Nicolas Lambert, Timothée Giraud,  Matthieu Viry, Ronan Ysebaert"
date: 06/7/2023
date-format: "DD MMM YYYY"
title-slide-attributes:
  data-background-color: black
  data-background-image: fig/SAGEO.png
  data-background-size: cover
  data-background-opacity: "0.5"
format:
  revealjs:
    margin: 0
    embed-resources: true
    smaller: true
    scrollable: false
    theme: [simple, custom.scss]
    code-line-numbers: false
execute:
  echo: true
---

```{r reticulate-env}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```

## Python

:::: columns
::: {.column width="70%"}
- **Python** : un langage *polyvalent*, *interprété* et *multi-paradigme*

- De plus en plus utilisé pour la *science des données*

:::{.fragment}
- Un écosystème robuste pour différents domaines d'application scientifiques

![](./fig/python-stack.png)
:::

:::

::: {.column width="30%"}
![](./fig/logo-python.png)

:::
::::

## Écosystème pour le géospatial

## Écosystème pour le géospatial - vecteur

::: columns
::: {.column width="66%"}
-   [**Bindings Python de GDAL/OGR**](https://gdal.org/api/python_bindings.html)
-   [**Fiona**](https://fiona.readthedocs.io/en/stable/) - I/O (*wrapper* de haut niveau autour d'OGR)
-   [**Shapely**](https://shapely.readthedocs.io/) (bindings Python de GEOS)
-   [**Pyproj**](https://pyproj4.github.io/pyproj) (bindings Python de [PROJ](https://proj.org/))
-   [**Geopandas**](https://geopandas.org/) - Étend les `DataFrame`s de [pandas](https://pandas.pydata.org/) pour ... (basé sur Fiona / Shapely / Pyproj)
:::

::: {.column width="33%"}
![](./fig/logo-pandas.svg)

![](./fig/logo_geopandas.svg)
:::
:::

## Écosystème pour le géospatial - *GeoPandas*

*"GeoPandas is an open source project to make working with geospatial data in python easier. GeoPandas extends the datatypes used by pandas to allow spatial operations on geometric types. Geometric operations are performed by shapely. Geopandas further depends on fiona for file access and matplotlib for plotting."*

![Format des GeoDataFrame](./fig/geopandas-table.png)

## Écosystème pour le géospatial - raster

-   [**Rasterio**](https://rasterio.readthedocs.io/) :
    * lecture / écriture de raster (*wrapper* de haut niveau autour de GDAL)
    * données représentées sous forme d'`array` NumPy
    * reprojection
    * _resampling_
    * _virtual files_
    * etc.

-   [**Rasterstats**](https://pythonhosted.org/rasterstats/) :
    * résumer des données raster sur la base de géométries vectorielles
    * extraction de valeurs à un point précis

- [**xarray**](https://docs.xarray.dev/en/stable/) et [**rioxarray**](https://corteva.github.io/rioxarray/) :
    * *xarray* pour travailler avec des tableaux multidimensionnels étiquetés
    * *rioxarray* pour ouvrir des jeux des données raster avec *rasterio* et les stocker dans le format de *xarray*
    * moins "rustique" que d'utiliser rasterio seul / dépend des usages

## Écosystème pour le géospatial - *Rasterio*

Exemple d'utilisation :

```{python example-rio-1}
import rasterio as rio

with rio.open('data/MODIS_ARRAY.nc') as f:
    # Métadonnées :
    metadata = f.meta
    # Lire toutes les bandes :
    data = f.read()
    # Ou f.read(1) pour lire seulement la première bande
```

- Un dictionnaire de méta-données + un tableau NumPy contenant la (ou les) bande(s) :

```{python example-rio-2}
print(metadata)
print(data)
```

## Écosystème pour le géospatial - *Xarray*

Exemple d'utilisation :

```{python example-rioxarray-1}
import rioxarray
import xarray
import matplotlib.pyplot as plt

xds = xarray.open_dataarray("./data/MODIS_ARRAY.nc")
```

- Un objet de type `xarray.DataArray` ou `xarray.Dataset` qui contient les différentes méta-données et les données :

```{python example-rioxarray-2}
print(xds)
```

## Écosystème pour le géospatial - *Xarray*

```{python example-rioxarray-3}
# Interpolate missing data:
filled = xds.rio.interpolate_na()

fig = plt.figure(figsize=(15, 5))
ax1, ax2 = (fig.add_subplot(131), fig.add_subplot(133))

xds.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax1)
filled.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax2)
```

## Écosystème pour le géospatial - autre

:::: columns
::: {.column width="55%"}
-   Binding Python pour [GRASS](https://grass.osgeo.org/grass82/manuals/libpython/index.html) + Intégration dans les notebooks Jupyter
:::

::: {.column width="45%"}
![Source: <https://grass.osgeo.org/news/2022_06_05_results_student_grant_caitlin/>](./fig/grass_jupyter_combo_vis.png)
:::
::::

## Écosystème pour le géospatial - Analyse spatiale

:::: {.columns}

::: {.column width="80%"}

Écosystème de bibliothèques pour l'analyse spatiale [PySAL](https://pysal.org/) (Python Spatial Analysis Library) :

- **Explorer**:
  - Analyse exploratoire des données spatiales (package [esda](https://pysal.org/esda/))
  - Analyse de la dynamique des données spatiales longitudinales (package [giddy](https://pysal.org/giddy/))
  - Mesure des inégalités dans l'espace et dans le temps (package [inequality](https://inequality.readthedocs.io/en/latest/))
  - Analyse statistique de motifs ponctuels planaires (package [pointpats](https://pysal.org/pointpats/))
  - Mesure de la ségrégation dans le temps et dans l'espace (package [segregation](https://pysal.org/segregation/))
  - Morphométrie urbaine (package [momepy](https://docs.momepy.org/en/stable/))

:::

::: {.column width="20%"}

![](./fig/logo-pysal.png)
:::

::::

## Écosystème pour le géospatial - Analyse spatiale

:::: {.columns}

::: {.column width="80%"}

Écosystème de bibliothèques pour l'analyse spatiale [PySAL](https://pysal.org/) (Python Spatial Analysis Library) :

- **Modéliser**:
  - Régression géographiquement pondérée à plusieurs échelles (package [mgwr](https://mgwr.readthedocs.io/en/latest/))
  - Modèles linéaires généralisés épars (package [spglm](https://spglm.readthedocs.io/en/latest/))
  - Modèles d'interaction spatiale (package [spint](https://spint.readthedocs.io/en/latest/))
  - Modèles de régression spatiale (package [spreg](https://spreg.readthedocs.io/en/latest/))
  - Modèles de composantes de variance à corrélation spatiale à plusieurs niveaux (package [spvcm](https://github.com/pysal/spvcm))
  - *Areal interpolation* et cartographie dasymétrique (package [tobler](https://pysal.org/tobler/))
  - Accessibilité spatiale (package [access](https://pysal.org/access/))
  - Optimisation spatiale (package [spopt](https://pysal.org/spopt/))
:::

::: {.column width="20%"}

![](./fig/logo-pysal.png)
:::

::::

## Ressources Python Géospatial

- Yes

- No

- Maybe

## Interaction R ⇄ Python dans Quarto

::: {.panel-tabset}

### R → Python

- Définition de variable dans un chunk R :

```{r example-r-1}
a <- 42
b <- list(1, 2, 3)
c <- c(12, 13, 14)
```

- Récupération depuis un chunk Python :

*en utilisant la variable `r`, un point, et le nom de la variable R à récupérer*

```{python example-python-1}
print(r.a)
print(r.b)
print(r.c)
```


### Python → R

- Définition de variable dans un chunk Python :

```{python example-python-2}
a = 42
b = [1, 2, 3]
```

- Récupération depuis un chunk R :

*en utilisant la variable `py`, un dollar `$`, et le nom de la variable Python à récupérer*

```{r example-r-2}
print(py$a)
print(py$b)
```


:::

## Interaction R ⇄ Python dans Quarto (suite)

<br><br><br><br>

- Il est possible d'échanger des types plus complexes (`data.frame` ⇄ `DataFrame` pandas, tableau numpy, etc.)

## Interaction R ⇄ Python dans Quarto (suite)

::: {.panel-tabset}

### R → Python

- Depuis un chunk R :

```{r example-r-3}
df <- data.frame(
   emp_id = c(1:5),
   emp_name = c("Rick","Dan","Michelle","Ryan","Jane"),
   salary = c(623.3,515.2,611.0,729.0,843.25),
   start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27")),
   stringsAsFactors = FALSE
)
```

- Récupération depuis un chunk Python :

```{python example-python-3}
df = r.df
print(df.head())
```


### Python → R

- Depuis un chunk Python :

```{python example-python-4}
import pandas as pd
import numpy as np

df2 = pd.DataFrame({
  "emp_id": list(range(5)),
  "emp_name": ["Rick", "Dan", "Michelle", "Ryan", "Jane"],
  "salary": [623.3, 515.2, 611.0, 729.0, 843.25],
  "start_date": pd.to_datetime(["2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27"]),
})

arr = np.array([[12, 47], [34, 90], [23, 19]])
```

- Utilisation depuis un chunk R :

```{r example-r-4}
head(py$df2)
print(py$arr)
```

:::

## Interaction R ⇄ Python dans Quarto (suite)

Et pour les objets spatiaux ? (*sf* / *geopandas*)

- Si la conversion `data.frame` ⇄ `DataFrame` est transparente, il n'en est pas de même pour les dataframe avec une composante spatiale (perte de la dimension spatiale / colonne `geometry` contient désormais ...)

- L'écriture d'une petite function permet de résoudre ça :

```{r import}
#| message: false
#| echo: false
# Import des données
library(sf)
mun_raw <- st_read("geom/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("geom/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
crs <- "EPSG:6623"
mun <- st_transform(mun_raw, crs)
mrc <- st_transform(mrc_raw, crs)
# Création d'une couche des régions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
```

```{python}
from shapely.geometry import shape
import geopandas as gpd

def restore_geodataframe(df, crs, geom_type):
  geom = df.geometry.apply(lambda coords: shape({ "type": geom_type, "coordinates": coords }))
  gdf = gpd.GeoDataFrame(df.drop(['geometry'], axis=1), geometry=geom)
  gdf.set_crs(crs, inplace=True)
  return gdf
```

Ainsi, les objets `sf` pourront être convertis en `GeoDataFrame` ainsi :

```{python}
my_df = restore_geodataframe(r.mun, r.crs, "MultiPolygon")
my_df.head()
```


## Python, Quarto et interactivité

- Utilisation des widgets Jupyter possible (seulement is utilisation de l'engin de rendu `jupyter`, pas avec `knitr` - i.e. l'inverse des *htmlwidgets* en R qui ne fonctionne que si `knitr` est utilisé)

- Exemple :

## Python et géospatial dans Quarto

-   Les imports nécessaires :

```{python demo-import}
import numpy as np
import rasterio as rio
import pandas as pd
import geopandas as gpd

from rasterio.warp import calculate_default_transform, reproject, Resampling
from matplotlib import pyplot as plt
from rasterio.plot import show
from rasterstats import zonal_stats
```

-   On ouvre les jeux de données :

```{python demo-dataset-opening}
reg_fp = './geom/regio_l.shp'
mun_fp = './geom/munic_s.shp'
lc_fp = '../../Téléchargements/T01_PROVINCE.tif'
lc_categories_fp = '../../Téléchargements/correspondance_raster_CL_COUV.dbf'
dst_epsg_code = 6623

regio_s = gpd.read_file(reg_fp).to_crs(epsg=dst_epsg_code)
munic_s = gpd.read_file(mun_fp).to_crs(epsg=dst_epsg_code)
```

## Python et géospatial dans Quarto

-   Séléction de la zone qu'on souhaite étudier, en utilisant une variable de l'environnement R :

```{python}
# sel = r.sel
sel = 'Québec'
```

-   On extrait les entités correspondantes et on les affiche, relativement au reste de la province :

```{python}
extract = munic_s[munic_s.MUS_NM_MUN == sel]

ax = munic_s.plot(color="lightblue", edgecolor="grey", alpha=0.5)
ax = regio_s.plot(ax=ax, color="orange", alpha=0.8)
ax = extract.plot(ax=ax, color="red")
ax
```

## Python et géospatial dans Quarto

-   Ouverture et reprojection d'un jeu de données raster

```{python}
dst_crs = f'EPSG:{dst_epsg_code}'

with rio.open(lc_fp) as src:
    transform, width, height = calculate_default_transform(
        src.crs, dst_crs, src.width, src.height, *src.bounds)
    kwargs = src.meta.copy()
    kwargs.update({
        'crs': dst_crs,
        'transform': transform,
        'width': width,
        'height': height
    })
    
    # Lecture de la première bande
    band = src.read(1)

    # Création du tableau de destination
    img = np.zeros_like(band)

    # Reprojection and stockage du
    # résultat dans le tableau de destination
    reproject(
        band,
        img,
        src_transform=src.transform,
        src_crs=src.crs,
        dst_transform=transform,
        dst_crs=dst_crs,
        resampling=Resampling.nearest,
    )

    # Stockage de l'extent de notre raster (on en aura besoin plus tard)
    left = transform[2]
    top = transform[5]
    right = left + transform[0] * width
    bottom = top + transform[4] * height
    extent = [left, right, bottom, top]
```

## Python et géospatial dans Quarto

```{python}
# Remplacer les '255' par '0'
img[img == 255] = 0

# Création d'une figure vide
fig, ax = plt.subplots(figsize=(16, 12))
# Affichage du raster, en utilisant son extent calculée précédemment
show(img, ax=ax, extent=extent, cmap="Set3")
# Affichage de la ville de Québec en rouge par dessus
extract.plot(ax=ax, color='red', edgecolor='red', linewidth=2)

```

## Python et géospatial dans Quarto

```{python}
# Ouverture du fichier DBF qui contient les correspondances entre les
# codes et les noms des catégories d'utilisation des sols
categories = pd.DataFrame(gpd.read_file(lc_categories_fp, encoding='utf-8')[['ID', 'CL_COUV', 'Descriptio']])
categories.head(11)
```

## Python et géospatial dans Quarto

-   Calculer les statistiques zonales (combien de cellules de chaque type dans la sélection) :

```{python}
stats = zonal_stats(extract, img, affine=transform, categorical=True, nodata=0)
stats
```

-   Regroupons les valeurs dans un seul dictionnaire :

```{python}
# Nous convertissons les objets dict en objets Counter,
# ce qui nous permet de les additionner en utilisant simplement l'opérateur "+".
from collections import Counter
stats = Counter(stats[0]) + Counter(stats[1])
stats = dict(stats) # Convert back to dict
stats
```

## Python

-   Traçons un histogramme de ce résultat, en utilisant les noms appropriés des catégories d'utilisation des sols :

```{python}
#| output-location: slide 
# Utilise les noms de catégories du DataFrame `categories`...
x = [
  categories[categories.ID == int(v)]['Descriptio'].iloc[0]
  for v in stats.keys()
]
# ...et les valeurs que nous venons de calculer avec la fonction `zonal_stats`
height = stats.values()

fig, ax = plt.subplots(figsize=(8, 5))
bar_container = ax.bar(x, height)
ax.set_xticklabels(
    ax.get_xticklabels(),
    rotation=45,
    horizontalalignment='right'
)
ax
```
