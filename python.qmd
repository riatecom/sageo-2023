---
title: "Articulation de diff√©rents langages (R, JavaScript et Python) pour la g√©ovisualisation avec Quarto"
subtitle: "Atelier Sageo, Qu√©bec, Juin 2023"
author: "Timoth√©e Giraud, Nicolas Lambert, Matthieu Viry, Ronan Ysebaert (UAR RIATE, CNRS, Universit√© Paris Cit√©)"
format:
  html:
    theme: sandstone
    fontsize: 0.9em
    code-tools: true
    toc: true
    toc-depth: 2
    linkcolor: "#8631ad"
execute: 
  cache: false
editor_options: 
  chunk_output_type: console

bibliography: references.bib
csl: "universite-de-montreal-apa.csl"
lang: fr
---

```{r reticulate-env}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```

```{python pandas-column-width-setup}
#| echo: false
import pandas as pd
pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
```

# Python

## Le langage Python

:::: columns
::: {.column width="70%"}
- **Python** : un langage *polyvalent*, *interpr√©t√©* et *multi-paradigme*

- De plus en plus utilis√© pour la *science des donn√©es*

:::{.fragment}
- Un √©cosyst√®me robuste pour diff√©rents domaines d'application scientifiques

![](./fig/python-stack.png)
:::

:::

::: {.column width="30%"}
![](./fig/logo-python.png)

:::
::::

## √âcosyst√®me pour le g√©ospatial

## Donn√©es vectorielles

-   [**Bindings Python de GDAL/OGR**](https://gdal.org/api/python_bindings.html) [@GDAL]
-   [**Fiona**](https://fiona.readthedocs.io/en/stable/) [@fiona] - I/O (*wrapper* de haut niveau autour d'OGR)
-   [**Shapely**](https://shapely.readthedocs.io/)  [@sgillies_2023] - bindings Python de [GEOS](https://github.com/libgeos/geos) [@GEOS]
-   [**Pyproj**](https://pyproj4.github.io/pyproj) [@pyproj] - bindings Python de [PROJ](https://proj.org/) [@PROJ]
-   [**Geopandas**](https://geopandas.org/)  [@kelsey_jordahl_2020_3946761] - √âtend les `DataFrame`s de [pandas](https://pandas.pydata.org/) [@pandas]

![](./fig/logo-pandas.svg)

![](./fig/logo_geopandas.svg)

## Le package *GeoPandas*

Un projet open source pour faciliter le travail avec des donn√©es g√©ospatiales vectorielles en Python. GeoPandas √©tend Pandas pour permettre de disposer d'un type de colonne g√©om√©trique et pour permettre d'effectuer des op√©rations spatiales. Les op√©rations g√©om√©triques sont r√©alis√©es avec `shapely`, les acc√®s en lecture / √©criture aux fichiers utilisent `fiona` et la visualisation utilise `matplotlib`.

![Format des GeoDataFrame](./fig/geopandas-table.png)

- Utilisation :

::: {.panel-tabset .custom-tab}

### Import et lecture

```{python gpd-tuto-import-1}
#| echo: false
import geodatasets

file_path = geodatasets.get_path("nybb")
```

Avec la fonction `read_file` :

```{python gpd-tuto-import-2}
import geopandas as gpd

nybb = gpd.read_file(file_path)
```

### Affichage

Avec la m√©thode `plot` des `GeoDataFrame` :

```{python gpd-tuto-plot}
nybb.plot()
```

### SCR

Affichage :

```{python gpd-tuto-crs}
print(nybb.crs)
```

Transformation :

```{python gpd-tuto-transformation}
nybb_geo = nybb.to_crs('EPSG:4326')
```

### Affichage avec fond de carte

En utilisant la biblioth√®que `contextily` :

```{python gpd-tuto-contextily}
import contextily as cx

ax = nybb.to_crs('EPSG:3857').plot()
cx.add_basemap(ax, source='https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png')
ax.set_axis_off()
ax
```

### Centroide

Simplement en utilisant l'attribut `centroid` des `GeoDataFrame` :

```{python gpd-tuto-centroid}
nybb.centroid.plot()
```

### Boundary

Simplement en utilisant l'attribut `boundary` des `GeoDataFrame` :

```{python gpd-tuto-boundary}
nybb.boundary.plot()
```

### Zone tampon

En utilisant la m√©thode `buffer` des `GeoDataFrame` :

```{python gpd-tuto-buffer}
buff_nybb = nybb.buffer(3000)
```

```{python gpd-tuto-buffer-2}
ax = buff_nybb.plot(color="red")
nybb.plot(ax=ax, color="aliceblue")
```


### Aggr√©gation

En utilisant la m√©thode `dissolve` des `GeoDataFrame` :

```{python gpd-tuto-agg}
# On peut utiliser dissolve(by="nom_colonne") si on veut aggr√©ger selon les valeurs d'une colonne
agg = nybb.dissolve()
agg.plot()
```


### Intersection

En utilisant la m√©thode `intersection` des `GeoDataFrame` :

```{python gpd-tuto-intersection}
from shapely import wkt

point = wkt.loads('Point(998769.1146889535 174169.7607268664)')

intersecting = nybb.intersection(point.buffer(35000))
```

<br>

```{python gpd-tuto-intersectiob-2}
ax = nybb.plot()
ax = intersecting.plot(ax=ax, color="red")
ax
```

:::

## Donn√©es raster

-   [**Rasterio**](https://rasterio.readthedocs.io/) [@gillies_2019] :
    * lecture / √©criture de raster (*wrapper* de haut niveau autour de GDAL)
    * donn√©es repr√©sent√©es sous forme d'`array` NumPy
    * reprojection
    * _resampling_
    * _virtual files_
    * etc.

-   [**Rasterstats**](https://pythonhosted.org/rasterstats/) :
    * r√©sumer des donn√©es raster sur la base de g√©om√©tries vectorielles
    * extraction de valeurs √† un point pr√©cis

-   [**xarray**](https://docs.xarray.dev/en/stable/) [@xarray] et [**rioxarray**](https://corteva.github.io/rioxarray/) [@rioxarray]:
    * *xarray* pour travailler avec des tableaux multidimensionnels √©tiquet√©s
    * *rioxarray* pour ouvrir des jeux des donn√©es raster avec *rasterio*, les stocker dans le format de *xarray*, et avoir acc√®s √† diff√©rentes fonctionnalit√©s de *rasterio*
    * moins "rustique" que d'utiliser rasterio seul / d√©pend de l'usage souhait√©

## Le package *Rasterio*

Exemple d'utilisation :

```{python example-rio-1}
import rasterio as rio

with rio.open('data/MODIS_ARRAY.nc') as f:
    # M√©tadonn√©es :
    metadata = f.meta
    # Lire toutes les bandes :
    data = f.read()
    # Ou f.read(1) pour lire seulement la premi√®re bande
```

- Un dictionnaire de m√©ta-donn√©es + un tableau NumPy contenant la (ou les) bande(s) :

```{python example-rio-2}
print(metadata)
print(data)
```

## Les package *xarray* et *rioxarray*

Exemple d'utilisation :

::: {.panel-tabset .custom-tab}

### Import et lecture

```{python xarray-tuto-import-1}
import rioxarray
import xarray

xds = xarray.open_dataarray("./data/MODIS_ARRAY.nc")
```

- Un objet de type `xarray.DataArray` ou `xarray.Dataset` qui contient les diff√©rentes m√©ta-donn√©es et les donn√©es :

```{python xarray-tuto-import-2}
xds
```

### Compl√©tion des valeurs manquantes

```{python xarray-tuto-na}
filled = xds.rio.interpolate_na()
```

### Affichage

En utilisant la m√©thode `plot` des objets `xarray.DataArray` (ici apr√®s avoir s√©lections un *subset* des donn√©es) :

```{python xarray-tuto-plot}
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(15, 5))
ax1, ax2 = (fig.add_subplot(131), fig.add_subplot(133))

xds.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax1)
filled.isel(x=slice(0, 20), y=slice(0, 20)).plot(ax=ax2)
```

### SCR

- Affichage :

```{python xarray-tuto-crs-1}
xds.rio.crs
```

- Transformation :

```{python xarray-tuto-crs-2}
xds = xds.rio.reproject("EPSG:6623")
```

### D√©coupage

```{python xarray-tuto-clipping}
#| eval: false
clipped = xds.rio.clip(gdf.geometry.values, gdf.crs, drop=False, invert=True)
```

:::


## Analyse spatiale

:::: {.columns}

::: {.column width="80%"}

√âcosyst√®me de biblioth√®ques pour l'analyse spatiale [PySAL](https://pysal.org/) (Python Spatial Analysis Library, @pysal2007) :

- **Explorer**:
  - Analyse exploratoire des donn√©es spatiales (package [esda](https://pysal.org/esda/))
  - Analyse de la dynamique des donn√©es spatiales longitudinales (package [giddy](https://pysal.org/giddy/))
  - Mesure des in√©galit√©s dans l'espace et dans le temps (package [inequality](https://inequality.readthedocs.io/en/latest/))
  - Analyse statistique de motifs ponctuels planaires (package [pointpats](https://pysal.org/pointpats/))
  - Mesure de la s√©gr√©gation dans le temps et dans l'espace (package [segregation](https://pysal.org/segregation/))
  - Morphom√©trie urbaine (package [momepy](https://docs.momepy.org/en/stable/))

- **Mod√©liser**:
  - R√©gression g√©ographiquement pond√©r√©e √† plusieurs √©chelles (package [mgwr](https://mgwr.readthedocs.io/en/latest/))
  - Mod√®les lin√©aires g√©n√©ralis√©s √©pars (package [spglm](https://spglm.readthedocs.io/en/latest/))
  - Mod√®les d'interaction spatiale (package [spint](https://spint.readthedocs.io/en/latest/))
  - Mod√®les de r√©gression spatiale (package [spreg](https://spreg.readthedocs.io/en/latest/))
  - Mod√®les de composantes de variance √† corr√©lation spatiale √† plusieurs niveaux (package [spvcm](https://github.com/pysal/spvcm))
  - *Areal interpolation* et cartographie dasym√©trique (package [tobler](https://pysal.org/tobler/))
  - Accessibilit√© spatiale (package [access](https://pysal.org/access/))
  - Optimisation spatiale (package [spopt](https://pysal.org/spopt/))

:::

::: {.column width="20%"}

![](./fig/logo-pysal.png)
:::

::::


## Autres packages utiles ...

-   Binding Python pour [GRASS](https://grass.osgeo.org/grass82/manuals/libpython/index.html) + Int√©gration dans les notebooks Jupyter

![Source: <https://grass.osgeo.org/news/2022_06_05_results_student_grant_caitlin/>](./fig/grass_jupyter_combo_vis.png)

- [Iris](https://scitools-iris.readthedocs.io/en/stable/)

- Pour la cartographie : [cartopy](https://scitools.org.uk/cartopy/docs/latest/) ; [geoviews](https://geoviews.org/) et [geoplot](https://residentmario.github.io/geoplot/) bas√©s sur *cartopy* ; [PyGMT](https://www.pygmt.org/latest/) (selon les usages - pas de solution aussi aboutie que `mapsf` pour les cartes r√©alis√©es en SHS).

![](./fig/cartopy.png)

## Ressources Python G√©ospatial

- [https://py.geocompx.org/](https://py.geocompx.org/) [@Dorman2022]

- [https://geo-python-site.readthedocs.io/en/latest/](https://geo-python-site.readthedocs.io/en/latest/)

- [https://automating-gis-processes.github.io](https://automating-gis-processes.github.io)

- [https://www.earthdatascience.org/courses/use-data-open-source-python/](https://www.earthdatascience.org/courses/use-data-open-source-python/)

- [https://geographicdata.science/book/intro.html](https://geographicdata.science/book/intro.html)


## Interaction R ‚áÑ Python dans Quarto

::: {.panel-tabset}

### R ‚Üí Python

- D√©finition de variables dans un chunk R :

```{r example-r-1}
a <- 42
b <- list(1, 2, 3)
c <- c(12, 13, 14)
```

- R√©cup√©ration depuis un chunk Python :

*en utilisant la variable `r`, un point, et le nom de la variable R √† r√©cup√©rer*

```{python example-python-1}
print(r.a)
print(r.b)
print(r.c)
```


### Python ‚Üí R

- D√©finition de variables dans un chunk Python :

```{python example-python-2}
a = 42
b = [1, 2, 3]
```

- R√©cup√©ration depuis un chunk R :

*en utilisant la variable `py`, un dollar `$`, et le nom de la variable Python √† r√©cup√©rer*

```{r example-r-2}
print(py$a)
print(py$b)
```


:::

## Interaction R ‚áÑ Python dans Quarto (suite)

- Il est possible d'√©changer des types plus complexes (`data.frame` ‚áÑ `DataFrame` pandas, tableau numpy, etc.)


::: {.panel-tabset}

### R ‚Üí Python

- Depuis un chunk R :

```{r example-r-3}
df <- data.frame(
   emp_id = c(1:5),
   emp_name = c("Rick","Dan","Michelle","Ryan","Jane"),
   salary = c(623.3,515.2,611.0,729.0,843.25),
   start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27")),
   stringsAsFactors = FALSE
)
```

- R√©cup√©ration depuis un chunk Python :

```{python example-python-3}
df = r.df
print(df.head())
```


### Python ‚Üí R

- Depuis un chunk Python :

```{python example-python-4}
import pandas as pd
import numpy as np

df2 = pd.DataFrame({
  "emp_id": list(range(5)),
  "emp_name": ["Rick", "Dan", "Michelle", "Ryan", "Jane"],
  "salary": [623.3, 515.2, 611.0, 729.0, 843.25],
  "start_date": pd.to_datetime(["2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11", "2015-03-27"]),
})

arr = np.array([[12, 47], [34, 90], [23, 19]])
```

- Utilisation depuis un chunk R :

```{r example-r-4}
head(py$df2)
print(py$arr)
```

:::

## Interaction R ‚áÑ Python dans Quarto (suite)

Et pour les objets spatiaux ? (*sf* / *geopandas*)

- Si la conversion `data.frame` ‚áÑ `DataFrame` est transparente, il n'en est pas de m√™me pour les dataframe avec une composante spatiale (perte de la dimension spatiale / colonne `geometry` contient d√©sormais ...)

- L'√©criture d'une petite function permet de r√©soudre √ßa :

```{r import}
#| message: false
#| echo: false
# Import des donn√©es
library(sf)
mun_raw <- st_read("geom/munic.geojson", quiet= TRUE)
mrc_raw <- st_read("geom/mrc.geojson", quiet = TRUE)
# Projection NAD83 / Quebec Albers
crs <- "EPSG:6623"
mun <- st_transform(mun_raw, crs)
mrc <- st_transform(mrc_raw, crs)
# Cr√©ation d'une couche des r√©gions
reg <- aggregate(x = mrc[,'MUS_NM_REG'], 
                 by = list(REG = mrc$MUS_NM_REG), 
                 FUN = head, 1)
resto_raw <- st_read('geom/resto.geojson', quiet = TRUE)
resto <- st_transform(resto_raw, crs)

sel <- "Qu√©bec"
```

```{python}
from shapely.geometry import shape
import geopandas as gpd

def restore_geodataframe(df, crs, geom_type):
  geom = df.geometry.apply(lambda coords: shape({ "type": geom_type, "coordinates": coords }))
  gdf = gpd.GeoDataFrame(df.drop(['geometry'], axis=1), geometry=geom)
  gdf.set_crs(crs, inplace=True)
  return gdf
```


Ainsi, les objets `sf` pourront √™tre convertis en `GeoDataFrame` ainsi :

```{python}
mrc = restore_geodataframe(r.mrc, r.crs, "MultiPolygon")
mrc.head()
```

```{python}
resto = restore_geodataframe(r.resto, r.crs, "Point")
resto.head()
```

## Python, Quarto et interactivit√©

- Utilisation des widgets Jupyter possible (seulement is utilisation de l'engin de rendu `jupyter`, pas avec `knitr` - i.e. l'inverse des *htmlwidgets* en R qui ne fonctionne que si `knitr` est utilis√©)

- Exemple :

![](./fig/example-quarto-jupyter-widgets.jpg)

- Documentation : [https://quarto.org/docs/interactive/widgets/jupyter.html](https://quarto.org/docs/interactive/widgets/jupyter.html)

## Exemples d'analyse sur les donn√©es du Qu√©bec

-   Les imports n√©cessaires :

```{python demo-import}
import numpy as np
import rasterio as rio
import pandas as pd
import geopandas as gpd
import rioxarray
import xarray

from rasterio.warp import calculate_default_transform, reproject, Resampling
from matplotlib import pyplot as plt
from rasterio.plot import show
from rasterio.mask import mask
from rasterstats import zonal_stats, point_query
```

-   On r√©cup√®re les jeux de donn√©es et quelques autres infos (SRC, etc.) depuis l'environnement R :

```{python demo-vector-dataset-opening}
# Le SCR des donn√©es
dst_crs = r.crs

# On r√©cup√®re le jeu de donn√©es "mrc" (municipalit√©s r√©gionales de comt√©)
# et le jeu de donn√©es "resto"
mrc = restore_geodataframe(r.mrc, dst_crs, "MultiPolygon")
resto = restore_geodataframe(r.resto, dst_crs, "Point")
reg = mrc.dissolve(by="MUS_NM_REG")

sel = r.sel # Qu√©bec

# Chemin du jeu de donn√©es raster
# et du fichier contenant les descriptions des cat√©gories
lc_fp = '../../T√©l√©chargements/T01_PROVINCE.tif'
lc_categories_fp = '../../T√©l√©chargements/correspondance_raster_CL_COUV.dbf'
```

-   On extrait les entit√©s correspondantes et on les affiche, relativement au reste de la province :

```{python demo-first-plot}
extract = mrc[mrc.MUS_NM_MRC == sel]

ax = mrc.plot(color="lightblue", edgecolor="grey", alpha=0.5, figsize=(16, 12))
ax = reg.plot(ax=ax, color=None, edgecolor="orange", alpha=0.8)
ax = extract.plot(ax=ax, color="red")
ax.set_axis_off()
ax
```

-   Ouverture et reprojection d'un jeu de donn√©es raster (avec *rioxarray*) :

```{python demo-open-raster}
xds = rioxarray.open_rasterio(lc_fp)
xds = xds.rio.reproject(dst_crs)
xds
```

- Affichons le raster reprojet√© et l'emprise de la ville de Qu√©bec :

```{python demo-plot-raster}
# Remplacer les '255' par '0'
xds.data[xds.data == 255] = 0

# √âtendue des donn√©es
bounds = xds.rio.bounds()
extent = [bounds[0], bounds[2], bounds[1], bounds[3]]

# Cr√©ation d'une figure vide
fig, ax = plt.subplots(figsize=(16, 12))
# Affichage du raster (attribut 'data' de l'objet xds)
show(xds.data[0], ax=ax, extent=extent, cmap="Set3")
# Affichage de la ville de Qu√©bec en rouge par dessus
extract.plot(ax=ax, color='red', edgecolor='red', linewidth=2)
# On enl√®ve l'affichage des axes
ax.set_axis_off()
ax
```

- Ouverture du fichier DBF qui contient les correspondances entre les codes et les noms des cat√©gories d'utilisation des sols

```{python demo-open-dbf}
categories = pd.DataFrame(
  gpd.read_file(lc_categories_fp, encoding='utf-8')[['ID', 'CL_COUV', 'Descriptio']])
categories.head(11)
```

<br>

```{python}
# On va convertir cette DataFrame en un dictionnaire pour l'utiliser
# comme un mapping ID -> Description
categories = {
  int(k): v['Descriptio']
  for k,v in categories[['ID', 'Descriptio']].set_index('ID').to_dict(orient='index').items()
}
# Bien qu'il y ait une cat√©gorie 'Pas de donn√©es' (ID 10)
# certaines cellules ne comportent pas de valeur (nodata, ici avec la valeur 0)
categories[0] = 'Pas de donn√©es'
categories
```

-   Calculer les statistiques zonales (combien de cellules de chaque type dans la s√©lection) :

```{python}
stats = zonal_stats(extract, xds.data[0], affine=xds.rio.transform(), categorical=True, nodata=0)
stats
```

-   Tra√ßons un histogramme de ce r√©sultat, en utilisant les noms appropri√©s des cat√©gories d'utilisation des sols :

```{python}
#| output-location: slide 
# Utilise les noms de cat√©gories du DataFrame `categories`...
x = [categories[int(v)] for v in stats[0].keys()]

# ...et les valeurs que nous venons de calculer avec la fonction `zonal_stats`
height = stats[0].values()

fig, ax = plt.subplots(figsize=(8, 8))
bar_container = ax.bar(x, height)
ax.set_xticklabels(
    ax.get_xticklabels(),
    rotation=45,
    horizontalalignment='right'
)
fig.tight_layout()
ax
```

- Affichons un petit r√©sum√© utilisant des valeurs en m
- Dans quel type d'occupation du sol se trouvent les restaurants pr√©c√©demment r√©cup√©r√©s ?

```{python}
geoms = resto['geometry'].tolist()

resto["lc"] = [categories[int(x)] for x in point_query(vectors=geoms, raster=xds.data[0], nodata=0, affine=xds.rio.transform())]
resto.head()
```

- Quels restaurants ne sont pas situ√©s dans une zone artificialis√©e ?

```{python}
selection = resto[(resto.lc != 'Surfaces artificielles') & (resto.lc != 'Pas de donn√©es')]
selection
```


```{python}
ax = extract.plot(color=None, edgecolor="black")
ax = selection.plot(ax=ax, marker='x', color='red', markersize=8)
ax.set_axis_off()
ax
```

## A vous de jouer üöÄ

**Objectif** : Comparez l'occupation du sol de l'ensemble de la province du Qu√©bec √† l'occupation du sol de la MRC de Montr√©al.

- Vous cherchez √† obtenir :
    - 2 graphiques en barres (un pour le Qu√©bec et un pour la MRC de Montr√©al)
    - un r√©sum√© (pourquoi pas en HTML !) de la surface de chaque type d'occupation du sol, comme celui pr√©sent√© en exemple ci-dessous
    
![Exemple de tableau de r√©sum√©](./fig/summary-lc.png)

- Au d√©but de votre document, vous devez ins√©rer un chunk de code `R` pour pr√©ciser la localisation de votre environnement virtuel Python - comme nous utilisons `knitr`, c'est ce qui va permettre √† `reticulate` de savoir o√π chercher les packages Python qui ont √©t√© install√©s pour cet atelier :

````
```{{r}}
#| echo: false
library(reticulate)
use_virtualenv("~/env-quarto")
```
````

**_Besoin d'aide ?_**

::: {.callout-tip icon=false collapse="true"}
### Quelle suite d'action r√©aliser ?

- Cr√©er un chunk 'r' pour dfinir la localisation de l'environnement virtuel
- Cr√©er les chunks 'python' correspondants aux actions suivantes :
    - Ouvrir le jeu de donn√©es raster
    - Ouvrir le jeu de donn√©es vecteur
    - S'assurer qu'ils sont dans le m√™me syst√®me de coordonn√©es de r√©f√©rence et effectuer la transformation si ce n'est pas le cas
    - Obtenir les statistiques zonales pour l'ensemble de la province du Qu√©bec
    - Obtenir les statistiques zonales pour la MRC de Montr√©al
    - Produire les deux graphiques et un tableau synth√©tisant ces informations

:::

::: {.callout-tip icon=false collapse="true"}
### De quelles biblioth√®ques a-t-on besoin ?


```{python}
#| eval: false
import rioxarray
import xarray
import pandas as pd
import geopandas as gpd
import rasterstats
import matplotlib.pyplot as plt
```

:::

::: {.callout-tip icon=false collapse="true"}
### Besoin d'aide pour ouvrir les donn√©es raster ?


```{python}
#| eval: false
xds = xarray.open_dataarray("/chemin/vers/le/fichier")
```

:::

::: {.callout-tip icon=false collapse="true"}
### Besoin d'aide pour ouvrir les donn√©es vecteur ?


```{python}
#| eval: false
gdf = gpd.read_file('/chemin/vers/le/fichier')
```

:::

::: {.callout-tip icon=false collapse="true"}
### Comment connaitre la taille d'une cellule raster ?

En utilisant les param√®tres d√©crivant la matrice de transformation de g√©or√©f√©rencement du jeu de donn√©es raster en question (cette transformation fait correspondre les coordonn√©es ligne/colonne des pixels aux coordonn√©es du syst√®me de r√©f√©rence de l'ensemble de donn√©es) :

```{python}
#| eval: false
transform = xds.rio.transform()
```

Puis en utilisant la premi√®re et la cinqui√®me valeur qui repr√©sentent respectivement la largeur et la hauteur du pixel :

```{python}
#| eval: false
area_pixel = transform[0] * abs(transform[4]) # la hauteur est g√©n√©ralement n√©gative
```

:::

::: {.callout-tip icon=false collapse="true"}
### Comment faire pour qu'un *chunk* retourne du HTML ?

Par exemple en stockant du Markdown dans une cha√Æne de caract√®re et en le transformant en HTML avec `IPython.display.Markdown` :

```{python}
#| eval: false
from IPython.display import Markdown

rendu = '''
## R√©sum√©

| Cat√©gorie | Superficie |
|---------|----------|
| Aahah | 21.34 |
'''

Markdown(rendu)
```

:::
